{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PhotoFF Documentation","text":"<p>PhotoFF is a high-performance image processing library that uses CUDA to achieve exceptional processing speeds. Designed to maximize performance through efficient GPU memory management.</p>"},{"location":"#basic-example","title":"Basic Example","text":"<pre><code>from photoff.operations.filters import apply_gaussian_blur, apply_corner_radius\nfrom photoff.io import save_image, load_image\nfrom photoff import CudaImage\n\n# Load the image in GPU memory\nsrc_image: CudaImage = load_image(\"./assets/stock.jpg\")\n\n# Apply filters\napply_gaussian_blur(src_image, radius=5.0)\napply_corner_radius(src_image, size=200)\n\n# Save the result\nsave_image(src_image, \"./assets/gaussian_blur_test.png\")\n\n# Free the image from GPU memory\nsrc_image.free()\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Pythonic Interface: Clean, intuitive API designed for both beginners and advanced users</li> <li>Robust Image Manipulation: Comprehensive suite of operations including filters, transforms, and compositing</li> <li>Seamless Integration: Works with common image formats through PIL interoperability</li> <li>CUDA-Accelerated Processing: Harness the power of your GPU for blazing-fast image operations</li> <li>Memory-Efficient Design: Optional advanced memory management for optimized buffer management</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, you can:</p> <ul> <li>Explore the Basic Operations to learn about loading, saving, and manipulating images</li> <li>Dive into the Advanced Operations to discover more complex image processing techniques</li> <li>Check out the API Reference for detailed documentation on all available functions and classes</li> </ul>"},{"location":"advanced/","title":"PhotoFF Advanced Topics","text":"<p>This guide covers advanced techniques for optimizing performance when working with the PhotoFF library, with special focus on efficient GPU memory management through buffer reuse.</p>"},{"location":"advanced/#understanding-gpu-memory-management","title":"Understanding GPU Memory Management","text":""},{"location":"advanced/#the-cost-of-gpu-memory-operations","title":"The Cost of GPU Memory Operations","text":"<p>When working with CUDA-accelerated image processing, memory operations are among the most expensive:</p> <ol> <li>Allocations: Each call to <code>CudaImage()</code> triggers a <code>cudaMalloc()</code> operation which is relatively slow</li> <li>Transfers: Moving data between CPU and GPU memory is extremely expensive</li> </ol> <p>PhotoFF provides several strategies to minimize these costs:</p>"},{"location":"advanced/#strategic-buffer-reuse-patterns","title":"Strategic Buffer Reuse Patterns","text":""},{"location":"advanced/#1-operation-output-caching","title":"1. Operation Output Caching","text":"<p>Many operations naturally produce new output (resize, crop, filters). PhotoFF allows passing pre-allocated destination buffers instead of creating new memory:</p> <pre><code>from photoff.operations.fill import fill_gradient\nfrom photoff.operations.resize import resize, ResizeMethod\nfrom photoff.io import save_image\nfrom photoff import CudaImage, RGBA\n\n# Pre-allocate source and destination buffers once\noriginal = CudaImage(1920, 1080)\nresized_cache = CudaImage(800, 600)\n\n# Fill the original image with a gradient\nfill_gradient(original, RGBA(0, 0, 0, 255), RGBA(255, 255, 255, 255))\n\n# Use pre-allocated buffer as destination\nresize(original, 800, 600, method=ResizeMethod.BICUBIC, resize_image_cache=resized_cache)\n\n# Save the resized image\nsave_image(resized_cache, \"./resized_image.png\")\n</code></pre>"},{"location":"advanced/#2-temporary-buffer-reuse","title":"2. Temporary Buffer Reuse","text":"<p>Some operations like blur, shadow, and stroke require a copy of the original image for internal calculations. You can reuse the same temporary buffer across multiple operations:</p> <pre><code>from photoff.operations.filters import apply_gaussian_blur\nfrom photoff.core.buffer import copy_buffers_same_size\nfrom photoff.io import save_image, load_image\nfrom photoff import CudaImage, RGBA\n\n# Create main image and shared temporary buffer\ntemp_buffer = CudaImage(5000, 5000)  # Example for extra buffer space\n\nimage = load_image(\"./assets/stock.jpg\")\n\ntemp_buffer.height = image.height # Set the same size as the main image\ntemp_buffer.width = image.width # Set the same size as the main image\n\n# Copy the main image to the temporary buffer\ncopy_buffers_same_size(temp_buffer.buffer, image.buffer, image.width, image.height) \n\n# Apply the Gaussian blur to the main image, using the temporary buffer as a cache\napply_gaussian_blur(image, radius=5.0, image_copy_cache=temp_buffer)\n\nsave_image(image, \"./test.png\")\n</code></pre>"},{"location":"advanced/#3-logical-dimension-adjustment-the-core-optimization-technique","title":"3. Logical Dimension Adjustment - The Core Optimization Technique","text":"<p>The most powerful feature in PhotoFF is the ability to allocate a large maximum memory buffer once, and then dynamically change its logical dimensions as needed:</p> <pre><code>from photoff.core.types import CudaImage\nfrom photoff.operations.resize import resize, ResizeMethod\n\n# Allocate ONE large buffer with maximum dimensions you'll ever need\n# This is the key pattern - allocate once, reuse everywhere\nmulti_purpose_buffer = CudaImage(5000, 5000)  # 5000x5000 memory allocated\n\n# Now you can change the logical dimensions at any time\n# IMPORTANT: This only changes metadata, not the actual memory allocation!\n# It simply tells PhotoFF functions how much of the buffer to read/write\nmulti_purpose_buffer.width = 800   # Just updates a property, no memory operation\nmulti_purpose_buffer.height = 600  # Just updates a property, no memory operation\n\n# Now use it as a destination buffer for operations\n# The function will only use the first 800x600 pixels of the allocated memory\nresize(source_image, 800, 600, resize_image_cache=multi_purpose_buffer)\n\n# Later, you can change to different dimensions (still using same memory)\nmulti_purpose_buffer.width = 1200   # Again, just changing metadata\nmulti_purpose_buffer.height = 900   # No memory allocation happens\nresize(another_image, 1200, 900, resize_image_cache=multi_purpose_buffer)\n</code></pre> <p>This technique is the heart of PhotoFF's memory optimization. The width and height properties are just metadata that tell operations how much of the pre-allocated memory to use - they don't trigger any GPU memory operations. This allows you to allocate once at startup and never worry about memory fragmentation again.</p>"},{"location":"advanced/#real-world-example-collage-generator","title":"Real-World Example: Collage Generator","text":"<p>The following example from a production collage generator demonstrates all three reuse patterns:</p> <pre><code>from photoff.core.types import CudaImage, RGBA\nfrom photoff.operations.filters import apply_corner_radius\nfrom photoff.operations.utils import cover_image_in_container\nfrom photoff.operations.resize import resize, ResizeMethod\n\n# Pre-allocate buffers once at module level\nPRINT_WIDTH, PRINT_HEIGHT = 2480, 3500\nPREVIEW_WIDTH, PREVIEW_HEIGHT = 600, 848\n\n# These buffers will be reused for all collages created\nprint_collage_cache = CudaImage(PRINT_WIDTH, PRINT_HEIGHT)\npreview_collage_cache = CudaImage(PREVIEW_WIDTH, PREVIEW_HEIGHT)\n\n# Create oversized buffers that will be logically resized as needed\n# This is critical - we allocate maximum needed size once\ncover_cache = CudaImage(5000, 5000)\ncover_resize_cache = CudaImage(5000, 5000)\n\ndef create_collage(grid_data, corner_radius=50, background_color=RGBA(255, 255, 255, 255)):\n    # Reuse print_collage_cache instead of creating a new buffer\n    fill_color(print_collage_cache, background_color)\n\n    for cell in grid_data.cells:\n        # Calculate cell dimensions\n        width = x1_padded - x0_padded\n        height = y1_padded - y0_padded\n\n        # IMPORTANT: Adjust logical dimensions of oversized buffers\n        # This doesn't trigger any memory allocation as long as\n        # width/height are smaller than the allocated buffer size\n        cover_cache.width = width\n        cover_cache.height = height\n\n        # Calculate resize dimensions for cover fit\n        resize_size = get_cover_resize_dimensions(source_image, width, height)\n\n        # Adjust dimensions of the resize cache buffer\n        cover_resize_cache.width = resize_size[0]\n        cover_resize_cache.height = resize_size[1]\n\n        # Use both cache buffers in the operation\n        cover_image_in_container(\n            source_image,\n            width, height,\n            0, 0,\n            background_color,\n            container_image_cache=cover_cache,  # Reuse container buffer\n            resize_image_cache=cover_resize_cache  # Reuse resize buffer\n        )\n\n        # Apply effects and blend with cached destination\n        apply_corner_radius(cover_cache, corner_radius)\n        blend(print_collage_cache, cover_cache, x_position, y_position)\n\n    # Create preview-sized version using another pre-allocated buffer\n    resize(\n        print_collage_cache, \n        PREVIEW_WIDTH, PREVIEW_HEIGHT, \n        method=ResizeMethod.BICUBIC,\n        resize_image_cache=preview_collage_cache  # Reuse preview buffer\n    )\n\n    # Return the preview image (no memory freed as buffers will be reused)\n    return preview_collage_cache\n</code></pre>"},{"location":"advanced/#buffer-validation-and-error-handling","title":"Buffer Validation and Error Handling","text":"<p>PhotoFF validates buffer dimensions before reusing them:</p> <pre><code># From resize.py\nif resize_image_cache.width != width or resize_image_cache.height != height:\n    raise ValueError(\n        f\"Destination image dimensions must match resize dimensions: {width}x{height}, got {resize_image_cache.width}x{resize_image_cache.height}\"\n    )\n</code></pre> <p>This ensures that reused buffers have appropriate dimensions for the operation.</p>"},{"location":"advanced/#cuda-operation-implementation-details","title":"CUDA Operation Implementation Details","text":"<p>Looking at the CUDA implementation, we can see how operations are designed to work with pre-allocated buffers:</p> <pre><code>// Example from photoff.cu - gaussian blur implementation\nvoid apply_gaussian_blur(uchar4* buffer,          // Destination buffer\n                         const uchar4* copy_buffer,  // Source buffer (original image copy)\n                         uint32_t width,\n                         uint32_t height,\n                         float radius) {\n    // Use CUDA kernel with provided buffers\n    gaussianBlurKernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(copy_buffer, buffer, width, height, radius);\n    cudaDeviceSynchronize();\n}\n</code></pre>"},{"location":"advanced/#advanced-buffer-management-strategies","title":"Advanced Buffer Management Strategies","text":""},{"location":"advanced/#1-buffer-pooling","title":"1. Buffer Pooling","text":"<p>For complex applications, implement a buffer pool:</p> <pre><code>class BufferPool:\n    def __init__(self):\n        self.pools = {}  # Maps (width, height) to list of available buffers\n\n    def get_buffer(self, width, height):\n        key = (width, height)\n        if key in self.pools and self.pools[key]:\n            return self.pools[key].pop()\n        return CudaImage(width, height)\n\n    def release_buffer(self, buffer):\n        key = (buffer.width, buffer.height)\n        if key not in self.pools:\n            self.pools[key] = []\n        self.pools[key].append(buffer)\n\n    def clear(self):\n        for buffers in self.pools.values():\n            for buffer in buffers:\n                buffer.free()\n        self.pools.clear()\n</code></pre>"},{"location":"advanced/#2-use-oversized-buffers-with-dynamic-adjustment","title":"2. Use Oversized Buffers with Dynamic Adjustment","text":"<p>Pre-allocate buffers at maximum expected size, then adjust logical dimensions as needed:</p> <pre><code># Allocate maximum possible size\nmax_buffer = CudaImage(4000, 4000)\n\n# When processing a 800x600 image\nmax_buffer.width = 800\nmax_buffer.height = 600\nprocess_image(max_buffer)\n\n# When processing a 1200x900 image\nmax_buffer.width = 1200\nmax_buffer.height = 900\nprocess_image(max_buffer)\n</code></pre> <p>This approach is extremely efficient for processing multiple images of varying sizes.</p>"},{"location":"advanced/#3-context-managers-for-clean-resource-management","title":"3. Context Managers for Clean Resource Management","text":"<pre><code>from contextlib import contextmanager\n\n@contextmanager\ndef using_buffer_pool(buffer_pool, width, height):\n    buffer = buffer_pool.get_buffer(width, height)\n    try:\n        yield buffer\n    finally:\n        buffer_pool.release_buffer(buffer)\n\n# Usage\nwith using_buffer_pool(pool, 800, 600) as temp:\n    # Use temp buffer\n    pass  # Automatically released back to pool when done\n</code></pre>"},{"location":"advanced/#performance-monitoring","title":"Performance Monitoring","text":"<p>Track memory usage and operation timing:</p> <pre><code>from time import time\n\ndef timed_operation(name, func, *args, **kwargs):\n    start = time()\n    result = func(*args, **kwargs)\n    duration = time() - start\n    print(f\"{name} took {duration:.4f} seconds\")\n    return result\n\n# Usage\nresized = timed_operation(\"Resize operation\", \n                         resize, image, 800, 600, \n                         method=ResizeMethod.BICUBIC)\n</code></pre>"},{"location":"advanced/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>Pre-allocate buffers at the start of your application</li> <li>Oversized buffers with logical dimension adjustment are extremely efficient</li> <li>Reuse temporary buffers for operations that need them</li> <li>Batch similar operations to minimize context switching</li> <li>Monitor performance to identify memory bottlenecks</li> <li>Minimize host-device transfers by keeping processing on the GPU</li> <li>Size buffers appropriately for your maximum expected dimensions</li> <li>Have a clear ownership strategy for GPU resources to avoid leaks</li> </ol> <p>By implementing these advanced buffer management techniques, you can achieve exceptional performance with PhotoFF while maintaining clean, maintainable code.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#photoff.core.buffer","title":"<code>photoff.core.buffer</code>","text":""},{"location":"api/#photoff.core.buffer.copy_buffers_same_size","title":"<code>copy_buffers_same_size(dst, src, width, height)</code>","text":"<p>Copies data between two CUDA buffers of the same size.</p> <p>This is useful for in-GPU memory operations like duplicating an image or preparing a temporary working buffer.</p> <p>Parameters:</p> Name Type Description Default <code>dst</code> <code>CudaBuffer</code> <p>Destination buffer on the device.</p> required <code>src</code> <code>CudaBuffer</code> <p>Source buffer on the device.</p> required <code>width</code> <code>int</code> <p>Width of the image.</p> required <code>height</code> <code>int</code> <p>Height of the image.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>copy_buffers_same_size(tmp_buf, original_buf, 512, 512)</p> Source code in <code>photoff/core/buffer.py</code> <pre><code>def copy_buffers_same_size(dst: \"CudaBuffer\", src: \"CudaBuffer\", width: int, height: int) -&gt; None:\n    \"\"\"\n    Copies data between two CUDA buffers of the same size.\n\n    This is useful for in-GPU memory operations like duplicating an image or\n    preparing a temporary working buffer.\n\n    Args:\n        dst (CudaBuffer): Destination buffer on the device.\n        src (CudaBuffer): Source buffer on the device.\n        width (int): Width of the image.\n        height (int): Height of the image.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; copy_buffers_same_size(tmp_buf, original_buf, 512, 512)\n    \"\"\"\n\n    _lib.copy_buffers_same_size(dst, src, width, height)\n</code></pre>"},{"location":"api/#photoff.core.buffer.copy_to_device","title":"<code>copy_to_device(d_dst, h_src, width, height)</code>","text":"<p>Copies image data from host (CPU) to device (GPU) memory.</p> <p>Parameters:</p> Name Type Description Default <code>d_dst</code> <code>CudaBuffer</code> <p>Destination buffer in device memory.</p> required <code>h_src</code> <code>CudaBuffer</code> <p>Source buffer in host memory.</p> required <code>width</code> <code>int</code> <p>Width of the image.</p> required <code>height</code> <code>int</code> <p>Height of the image.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>copy_to_device(gpu_buf, cpu_buf, 256, 256)</p> Source code in <code>photoff/core/buffer.py</code> <pre><code>def copy_to_device(d_dst: \"CudaBuffer\", h_src: \"CudaBuffer\", width: int, height: int) -&gt; None:\n    \"\"\"\n    Copies image data from host (CPU) to device (GPU) memory.\n\n    Args:\n        d_dst (CudaBuffer): Destination buffer in device memory.\n        h_src (CudaBuffer): Source buffer in host memory.\n        width (int): Width of the image.\n        height (int): Height of the image.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; copy_to_device(gpu_buf, cpu_buf, 256, 256)\n    \"\"\"\n\n    _lib.copy_to_device(d_dst, h_src, width, height)\n</code></pre>"},{"location":"api/#photoff.core.buffer.copy_to_host","title":"<code>copy_to_host(h_dst, d_src, width, height)</code>","text":"<p>Copies image data from device (GPU) to host (CPU) memory.</p> <p>Parameters:</p> Name Type Description Default <code>h_dst</code> <code>CudaBuffer</code> <p>Destination buffer in host memory.</p> required <code>d_src</code> <code>CudaBuffer</code> <p>Source buffer in device memory.</p> required <code>width</code> <code>int</code> <p>Width of the image.</p> required <code>height</code> <code>int</code> <p>Height of the image.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>copy_to_host(cpu_buf, gpu_buf, 256, 256)</p> Source code in <code>photoff/core/buffer.py</code> <pre><code>def copy_to_host(h_dst: \"CudaBuffer\", d_src: \"CudaBuffer\", width: int, height: int) -&gt; None:\n    \"\"\"\n    Copies image data from device (GPU) to host (CPU) memory.\n\n    Args:\n        h_dst (CudaBuffer): Destination buffer in host memory.\n        d_src (CudaBuffer): Source buffer in device memory.\n        width (int): Width of the image.\n        height (int): Height of the image.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; copy_to_host(cpu_buf, gpu_buf, 256, 256)\n    \"\"\"\n\n    _lib.copy_to_host(h_dst, d_src, width, height)\n</code></pre>"},{"location":"api/#photoff.core.buffer.create_buffer","title":"<code>create_buffer(width, height)</code>","text":"<p>Allocates a new CUDA buffer for an image of given dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the buffer in pixels.</p> required <code>height</code> <code>int</code> <p>Height of the buffer in pixels.</p> required <p>Returns:</p> Name Type Description <code>CudaBuffer</code> <code>CudaBuffer</code> <p>A pointer to the allocated device memory buffer.</p> Example <p>buffer = create_buffer(512, 512)</p> Source code in <code>photoff/core/buffer.py</code> <pre><code>def create_buffer(width: int, height: int) -&gt; \"CudaBuffer\":\n    \"\"\"\n    Allocates a new CUDA buffer for an image of given dimensions.\n\n    Args:\n        width (int): Width of the buffer in pixels.\n        height (int): Height of the buffer in pixels.\n\n    Returns:\n        CudaBuffer: A pointer to the allocated device memory buffer.\n\n    Example:\n        &gt;&gt;&gt; buffer = create_buffer(512, 512)\n    \"\"\"\n\n    return _lib.create_buffer(width, height)\n</code></pre>"},{"location":"api/#photoff.core.buffer.free_buffer","title":"<code>free_buffer(buffer)</code>","text":"<p>Frees a CUDA buffer previously allocated on the device.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>CudaBuffer</code> <p>The buffer to free.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>free_buffer(buffer)</p> Source code in <code>photoff/core/buffer.py</code> <pre><code>def free_buffer(buffer: \"CudaBuffer\") -&gt; None:\n    \"\"\"\n    Frees a CUDA buffer previously allocated on the device.\n\n    Args:\n        buffer (CudaBuffer): The buffer to free.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; free_buffer(buffer)\n    \"\"\"\n\n    _lib.free_buffer(buffer)\n</code></pre>"},{"location":"api/#photoff.core.types","title":"<code>photoff.core.types</code>","text":""},{"location":"api/#photoff.core.types.CudaImage","title":"<code>CudaImage</code>","text":"<p>Represents an image stored in GPU memory with optional dimension constraints.</p> <p>The image has an underlying GPU buffer and stores its logical and allocated dimensions. Use <code>.width</code> and <code>.height</code> to manage the actual used size, while the allocation size is fixed on creation. Memory is managed via <code>create_buffer</code> and <code>free_buffer</code>.</p> <p>Attributes:</p> Name Type Description <code>width</code> <code>int</code> <p>Logical width (can be set lower than allocated width).</p> <code>height</code> <code>int</code> <p>Logical height (can be set lower than allocated height).</p> <code>buffer</code> <code>Any</code> <p>Pointer to the underlying CUDA buffer.</p> <p>Methods:</p> Name Description <code>init_image</code> <p>Allocates the GPU buffer if not already allocated.</p> <code>free</code> <p>Frees the associated GPU buffer.</p> Example <p>img = CudaImage(512, 512) img.width = 256  # Use only part of the allocation img.free()</p> Source code in <code>photoff/core/types.py</code> <pre><code>class CudaImage:\n    \"\"\"\n    Represents an image stored in GPU memory with optional dimension constraints.\n\n    The image has an underlying GPU buffer and stores its logical and allocated dimensions.\n    Use `.width` and `.height` to manage the actual used size, while the allocation\n    size is fixed on creation. Memory is managed via `create_buffer` and `free_buffer`.\n\n    Attributes:\n        width (int): Logical width (can be set lower than allocated width).\n        height (int): Logical height (can be set lower than allocated height).\n        buffer (CudaBuffer): Pointer to the underlying CUDA buffer.\n\n    Methods:\n        init_image(): Allocates the GPU buffer if not already allocated.\n        free(): Frees the associated GPU buffer.\n\n    Example:\n        &gt;&gt;&gt; img = CudaImage(512, 512)\n        &gt;&gt;&gt; img.width = 256  # Use only part of the allocation\n        &gt;&gt;&gt; img.free()\n    \"\"\"\n\n    def __init__(self, width: int, height: int, auto_init: bool = True):\n        \"\"\"\n        Initializes a new CudaImage with specified dimensions.\n\n        Args:\n            width (int): Allocation and initial logical width in pixels.\n            height (int): Allocation and initial logical height in pixels.\n            auto_init (bool, optional): Whether to automatically allocate the buffer. Defaults to True.\n        \"\"\"\n\n        self._alloc_width  = width\n        self._alloc_height = height\n\n        self._width  = width\n        self._height = height\n\n        self.buffer = None\n        if auto_init:\n            self.init_image()\n\n    @property\n    def width(self) -&gt; int:\n        return self._width\n\n    @width.setter\n    def width(self, value: int):\n        if value &gt; self._alloc_width:\n            raise ValueError(f\"width {value} &gt; alloc_width {self._alloc_width}\")\n        self._width = value\n\n    @property\n    def height(self) -&gt; int:\n        return self._height\n\n    @height.setter\n    def height(self, value: int):\n        if value &gt; self._alloc_height:\n            raise ValueError(f\"height {value} &gt; alloc_height {self._alloc_height}\")\n        self._height = value\n\n    def init_image(self):\n        if self.buffer is None:\n            self.buffer = create_buffer(self._alloc_width, self._alloc_height)\n\n    def free(self):\n        if self.buffer is not None:\n            free_buffer(self.buffer)\n            self.buffer = None\n</code></pre>"},{"location":"api/#photoff.core.types.CudaImage.__init__","title":"<code>__init__(width, height, auto_init=True)</code>","text":"<p>Initializes a new CudaImage with specified dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Allocation and initial logical width in pixels.</p> required <code>height</code> <code>int</code> <p>Allocation and initial logical height in pixels.</p> required <code>auto_init</code> <code>bool</code> <p>Whether to automatically allocate the buffer. Defaults to True.</p> <code>True</code> Source code in <code>photoff/core/types.py</code> <pre><code>def __init__(self, width: int, height: int, auto_init: bool = True):\n    \"\"\"\n    Initializes a new CudaImage with specified dimensions.\n\n    Args:\n        width (int): Allocation and initial logical width in pixels.\n        height (int): Allocation and initial logical height in pixels.\n        auto_init (bool, optional): Whether to automatically allocate the buffer. Defaults to True.\n    \"\"\"\n\n    self._alloc_width  = width\n    self._alloc_height = height\n\n    self._width  = width\n    self._height = height\n\n    self.buffer = None\n    if auto_init:\n        self.init_image()\n</code></pre>"},{"location":"api/#photoff.core.types.RGBA","title":"<code>RGBA</code>  <code>dataclass</code>","text":"<p>Represents an RGBA color with 8-bit channels.</p> <p>Attributes:</p> Name Type Description <code>r</code> <code>int</code> <p>Red channel (0 \u2013 255).</p> <code>g</code> <code>int</code> <p>Green channel (0 \u2013 255).</p> <code>b</code> <code>int</code> <p>Blue channel (0 \u2013 255).</p> <code>a</code> <code>int</code> <p>Alpha channel (0 \u2013 255), defaults to 255 (opaque).</p> Example <p>color = RGBA(255, 0, 0)  # Opaque red transparent_black = RGBA(0, 0, 0, 0)</p> Source code in <code>photoff/core/types.py</code> <pre><code>@_dataclass\nclass RGBA:\n    \"\"\"\n    Represents an RGBA color with 8-bit channels.\n\n    Attributes:\n        r (int): Red channel (0 \u2013 255).\n        g (int): Green channel (0 \u2013 255).\n        b (int): Blue channel (0 \u2013 255).\n        a (int): Alpha channel (0 \u2013 255), defaults to 255 (opaque).\n\n    Example:\n        &gt;&gt;&gt; color = RGBA(255, 0, 0)  # Opaque red\n        &gt;&gt;&gt; transparent_black = RGBA(0, 0, 0, 0)\n    \"\"\"\n    r: int\n    g: int\n    b: int\n    a: int = 255\n</code></pre>"},{"location":"api/#photoff.core.cuda_interface","title":"<code>photoff.core.cuda_interface</code>","text":""},{"location":"api/#photoff.io","title":"<code>photoff.io</code>","text":""},{"location":"api/#photoff.io.image_to_pil","title":"<code>image_to_pil(image)</code>","text":"<p>Converts a CudaImage to a PIL.Image in RGBA format.</p> <p>The image is copied from GPU memory to host memory and returned as a Pillow image object.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>The image in GPU memory.</p> required <p>Returns:</p> Type Description <code>Image</code> <p>PIL.Image: A new PIL Image with RGBA channels.</p> Example <p>pil_img = image_to_pil(cuda_img) pil_img.show()</p> Source code in <code>photoff/io/__init__.py</code> <pre><code>def image_to_pil(image: CudaImage) -&gt; Image:\n    \"\"\"\n    Converts a CudaImage to a PIL.Image in RGBA format.\n\n    The image is copied from GPU memory to host memory and returned\n    as a Pillow image object.\n\n    Args:\n        image (CudaImage): The image in GPU memory.\n\n    Returns:\n        PIL.Image: A new PIL Image with RGBA channels.\n\n    Example:\n        &gt;&gt;&gt; pil_img = image_to_pil(cuda_img)\n        &gt;&gt;&gt; pil_img.show()\n    \"\"\"\n\n    img_data = bytearray(image.width * image.height * 4)\n    data_ptr = ffi.from_buffer(img_data)\n    copy_to_host(ffi.cast(\"uchar4*\", data_ptr), image.buffer, image.width,\n                 image.height)\n    return Image.frombytes(\"RGBA\", (image.width, image.height),\n                           bytes(img_data))\n</code></pre>"},{"location":"api/#photoff.io.load_image","title":"<code>load_image(filename, container=None)</code>","text":"<p>Loads an image from disk and transfers it to a CudaImage.</p> <p>The image is loaded using Pillow and converted to RGBA format. It is then copied to GPU memory. Optionally, a pre-allocated CudaImage container can be used to avoid allocation.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the image file to load.</p> required <code>container</code> <code>CudaImage</code> <p>Pre-allocated image buffer. Must be large enough to hold the image.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>CudaImage</code> <code>CudaImage</code> <p>A new or reused image object with the loaded data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input image is larger than the provided container.</p> Example <p>cuda_img = load_image(\"texture.png\")</p> Source code in <code>photoff/io/__init__.py</code> <pre><code>def load_image(filename: str, container: CudaImage = None) -&gt; CudaImage:\n    \"\"\"\n    Loads an image from disk and transfers it to a CudaImage.\n\n    The image is loaded using Pillow and converted to RGBA format. It is then copied\n    to GPU memory. Optionally, a pre-allocated CudaImage container can be used to avoid allocation.\n\n    Args:\n        filename (str): Path to the image file to load.\n        container (CudaImage, optional): Pre-allocated image buffer. Must be large enough to hold the image.\n\n    Returns:\n        CudaImage: A new or reused image object with the loaded data.\n\n    Raises:\n        ValueError: If the input image is larger than the provided container.\n\n    Example:\n        &gt;&gt;&gt; cuda_img = load_image(\"texture.png\")\n    \"\"\"\n\n    img = Image.open(filename).convert(\"RGBA\")\n    width, height = img.size\n\n    if container is None:\n        container = CudaImage(width, height)\n\n    if width &gt; container.width or height &gt; container.height:\n        raise ValueError(\"Image dimensions exceed container dimensions\")\n\n    img_array = np.asarray(img, dtype=np.uint8)\n\n    c_buffer = ffi.cast(\"uchar4*\", img_array.ctypes.data)\n    copy_to_device(container.buffer, c_buffer, width, height)\n\n    container.width = width\n    container.height = height\n\n    return container\n</code></pre>"},{"location":"api/#photoff.io.save_image","title":"<code>save_image(image, filename)</code>","text":"<p>Saves a CudaImage to disk as a standard image file.</p> <p>This function converts the image from GPU memory to a Pillow image and saves it using the given filename. The format is inferred from the file extension.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>The image to save.</p> required <code>filename</code> <code>str</code> <p>Destination path, including extension (e.g., 'output.png').</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>save_image(cuda_img, \"output.png\")</p> Source code in <code>photoff/io/__init__.py</code> <pre><code>def save_image(image: CudaImage, filename: str) -&gt; None:\n    \"\"\"\n    Saves a CudaImage to disk as a standard image file.\n\n    This function converts the image from GPU memory to a Pillow image and saves it\n    using the given filename. The format is inferred from the file extension.\n\n    Args:\n        image (CudaImage): The image to save.\n        filename (str): Destination path, including extension (e.g., 'output.png').\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; save_image(cuda_img, \"output.png\")\n    \"\"\"\n\n    img = image_to_pil(image)\n    img.save(filename)\n    img.close()\n</code></pre>"},{"location":"api/#photoff.operations.blend","title":"<code>photoff.operations.blend</code>","text":""},{"location":"api/#photoff.operations.blend.blend","title":"<code>blend(background, over, x, y)</code>","text":"<p>Blends an image (<code>over</code>) on top of another (<code>background</code>) at a specified position.</p> <p>The blending respects the alpha channel of the overlaid image. No clipping is performed if the <code>over</code> image exceeds the bounds of the <code>background</code>; behavior in such cases depends on the underlying CUDA implementation.</p> <p>Parameters:</p> Name Type Description Default <code>background</code> <code>CudaImage</code> <p>The base image to draw onto.</p> required <code>over</code> <code>CudaImage</code> <p>The image to blend on top.</p> required <code>x</code> <code>int</code> <p>Horizontal position in the background where the top-left corner of <code>over</code> is placed.</p> required <code>y</code> <code>int</code> <p>Vertical position in the background where the top-left corner of <code>over</code> is placed.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>blend(bg_img, icon_img, x=100, y=50)</p> Source code in <code>photoff/operations/blend.py</code> <pre><code>def blend(background: CudaImage, over: CudaImage, x: int, y: int) -&gt; None:\n    \"\"\"\n    Blends an image (`over`) on top of another (`background`) at a specified position.\n\n    The blending respects the alpha channel of the overlaid image. No clipping is performed\n    if the `over` image exceeds the bounds of the `background`; behavior in such cases depends on the underlying CUDA implementation.\n\n    Args:\n        background (CudaImage): The base image to draw onto.\n        over (CudaImage): The image to blend on top.\n        x (int): Horizontal position in the background where the top-left corner of `over` is placed.\n        y (int): Vertical position in the background where the top-left corner of `over` is placed.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; blend(bg_img, icon_img, x=100, y=50)\n    \"\"\"\n    _lib.blend_buffers(background.buffer,\n                       over.buffer,\n                       background.width,\n                       background.height,\n                       over.width,\n                       over.height,\n                       x,\n                       y,\n                       )\n</code></pre>"},{"location":"api/#photoff.operations.fill","title":"<code>photoff.operations.fill</code>","text":""},{"location":"api/#photoff.operations.fill.fill_color","title":"<code>fill_color(image, color)</code>","text":"<p>Fills the entire image with a solid color.</p> <p>This operation overwrites all pixels in the image with the specified RGBA color.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>The image to fill.</p> required <code>color</code> <code>RGBA</code> <p>The fill color to apply.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>fill_color(img, RGBA(255, 255, 255, 255))  # Fill with solid white</p> Source code in <code>photoff/operations/fill.py</code> <pre><code>def fill_color(image: CudaImage, color: RGBA) -&gt; None:\n    \"\"\"\n    Fills the entire image with a solid color.\n\n    This operation overwrites all pixels in the image with the specified RGBA color.\n\n    Args:\n        image (CudaImage): The image to fill.\n        color (RGBA): The fill color to apply.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; fill_color(img, RGBA(255, 255, 255, 255))  # Fill with solid white\n    \"\"\"\n\n    _lib.fill_color(image.buffer,\n                    image.width,\n                    image.height,\n                    color.r,\n                    color.g,\n                    color.b,\n                    color.a)\n</code></pre>"},{"location":"api/#photoff.operations.fill.fill_gradient","title":"<code>fill_gradient(image, color1, color2, direction=0, seamless=False)</code>","text":"<p>Fills the image with a linear gradient between two colors.</p> <p>The gradient direction and style (seamless or linear) can be customized.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>The target image to fill.</p> required <code>color1</code> <code>RGBA</code> <p>The starting color of the gradient.</p> required <code>color2</code> <code>RGBA</code> <p>The ending color of the gradient.</p> required <code>direction</code> <code>int</code> <p>Gradient direction: - 0 = vertical (top to bottom) - 1 = horizontal (left to right) - 2 = diagonal (top-left to bottom-right) - 3 = diagonal (bottom-left to top-right) Defaults to 0.</p> <code>0</code> <code>seamless</code> <code>bool</code> <p>Whether the gradient should repeat seamlessly. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid direction value is provided.</p> Example <p>fill_gradient(img, RGBA(0, 0, 0, 255), RGBA(255, 255, 255, 255), direction=1)</p> Source code in <code>photoff/operations/fill.py</code> <pre><code>def fill_gradient(image: CudaImage,\n                  color1: RGBA,\n                  color2: RGBA,\n                  direction: int = 0,\n                  seamless: bool = False) -&gt; None:\n    \"\"\"\n    Fills the image with a linear gradient between two colors.\n\n    The gradient direction and style (seamless or linear) can be customized.\n\n    Args:\n        image (CudaImage): The target image to fill.\n        color1 (RGBA): The starting color of the gradient.\n        color2 (RGBA): The ending color of the gradient.\n        direction (int, optional): Gradient direction:\n            - 0 = vertical (top to bottom)\n            - 1 = horizontal (left to right)\n            - 2 = diagonal (top-left to bottom-right)\n            - 3 = diagonal (bottom-left to top-right)\n            Defaults to 0.\n        seamless (bool, optional): Whether the gradient should repeat seamlessly. Defaults to False.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If an invalid direction value is provided.\n\n    Example:\n        &gt;&gt;&gt; fill_gradient(img, RGBA(0, 0, 0, 255), RGBA(255, 255, 255, 255), direction=1)\n    \"\"\"\n    if direction not in (0, 1, 2, 3):\n        raise ValueError(f\"Invalid gradient direction: {direction}. Must be 0, 1, 2 or 3.\")\n\n    _lib.fill_gradient(image.buffer,\n                       image.width,\n                       image.height,\n                       color1.r,\n                       color1.g,\n                       color1.b,\n                       color1.a,\n                       color2.r,\n                       color2.g,\n                       color2.b,\n                       color2.a,\n                       direction,\n                       seamless,\n                       )\n</code></pre>"},{"location":"api/#photoff.operations.filters","title":"<code>photoff.operations.filters</code>","text":""},{"location":"api/#photoff.operations.filters.apply_chroma_key","title":"<code>apply_chroma_key(image, key_image, channel='A', threshold=128, invert=False, zero_all_channels=False)</code>","text":"<p>Applies a chroma key mask based on a channel of another image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>The target image to apply transparency.</p> required <code>key_image</code> <code>CudaImage</code> <p>Image whose channel values are used as a mask.</p> required <code>channel</code> <code>str</code> <p>Channel to use from the key image ('R', 'G', 'B', 'A'). Defaults to 'A'.</p> <code>'A'</code> <code>threshold</code> <code>int</code> <p>Threshold (0\u2013255) to apply masking. Defaults to 128.</p> <code>128</code> <code>invert</code> <code>bool</code> <p>Invert the mask logic. Defaults to False.</p> <code>False</code> <code>zero_all_channels</code> <code>bool</code> <p>If True, sets RGB to zero where mask applies. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided channel is invalid.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>photoff/operations/filters.py</code> <pre><code>def apply_chroma_key(image: CudaImage,\n                     key_image: CudaImage,\n                     channel: str = \"A\",\n                     threshold: int = 128,\n                     invert: bool = False,\n                     zero_all_channels: bool = False) -&gt; None:\n    \"\"\"\n    Applies a chroma key mask based on a channel of another image.\n\n    Args:\n        image (CudaImage): The target image to apply transparency.\n        key_image (CudaImage): Image whose channel values are used as a mask.\n        channel (str, optional): Channel to use from the key image ('R', 'G', 'B', 'A'). Defaults to 'A'.\n        threshold (int, optional): Threshold (0\u2013255) to apply masking. Defaults to 128.\n        invert (bool, optional): Invert the mask logic. Defaults to False.\n        zero_all_channels (bool, optional): If True, sets RGB to zero where mask applies. Defaults to False.\n\n    Raises:\n        ValueError: If the provided channel is invalid.\n\n    Returns:\n        None\n    \"\"\"\n\n    channel_upper = (channel.upper() if isinstance(channel, str) else str(channel).upper())\n\n    if channel_upper == \"R\":\n        channel_idx = 0\n    elif channel_upper == \"G\":\n        channel_idx = 1\n    elif channel_upper == \"B\":\n        channel_idx = 2\n    elif channel_upper == \"A\":\n        channel_idx = 3\n    else:\n        raise ValueError(f\"Invalid channel: {channel}, must be one of 'R', 'G', 'B', 'A'\")\n\n    _lib.apply_chroma_key(image.buffer,\n                          key_image.buffer,\n                          image.width,\n                          image.height,\n                          key_image.width,\n                          key_image.height,\n                          channel_idx,\n                          threshold,\n                          invert,\n                          zero_all_channels,\n                          )\n</code></pre>"},{"location":"api/#photoff.operations.filters.apply_corner_radius","title":"<code>apply_corner_radius(image, size)</code>","text":"<p>Applies a rounded corner mask to an image in-place.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>Image to be modified.</p> required <code>size</code> <code>int</code> <p>Radius of the corner in pixels.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>photoff/operations/filters.py</code> <pre><code>def apply_corner_radius(image: CudaImage, size: int) -&gt; None:\n    \"\"\"\n    Applies a rounded corner mask to an image in-place.\n\n    Args:\n        image (CudaImage): Image to be modified.\n        size (int): Radius of the corner in pixels.\n\n    Returns:\n        None\n    \"\"\"\n\n    _lib.apply_corner_radius(image.buffer, image.width, image.height, size)\n</code></pre>"},{"location":"api/#photoff.operations.filters.apply_flip","title":"<code>apply_flip(image, flip_horizontal=False, flip_vertical=False)</code>","text":"<p>Flips an image horizontally or vertically in-place.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>Image to flip.</p> required <code>flip_horizontal</code> <code>bool</code> <p>Flip the image horizontally. Defaults to False.</p> <code>False</code> <code>flip_vertical</code> <code>bool</code> <p>Flip the image vertically. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>flip_horizontal</code> and <code>flip_vertical</code> are True.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>photoff/operations/filters.py</code> <pre><code>def apply_flip(image: CudaImage,\n               flip_horizontal: bool = False,\n               flip_vertical: bool = False) -&gt; None:\n    \"\"\"\n    Flips an image horizontally or vertically in-place.\n\n    Args:\n        image (CudaImage): Image to flip.\n        flip_horizontal (bool, optional): Flip the image horizontally. Defaults to False.\n        flip_vertical (bool, optional): Flip the image vertically. Defaults to False.\n\n    Raises:\n        ValueError: If both `flip_horizontal` and `flip_vertical` are True.\n\n    Returns:\n        None\n    \"\"\"\n\n    if flip_horizontal and flip_vertical:\n        raise ValueError(\"Cannot flip both horizontal and vertical at the same time\")\n\n    _lib.apply_flip(image.buffer, image.width, image.height, flip_horizontal, flip_vertical)\n</code></pre>"},{"location":"api/#photoff.operations.filters.apply_gaussian_blur","title":"<code>apply_gaussian_blur(image, radius, image_copy_cache=None)</code>","text":"<p>Applies a Gaussian blur effect to an image in-place.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>Image to blur.</p> required <code>radius</code> <code>float</code> <p>Radius of the blur in pixels.</p> required <code>image_copy_cache</code> <code>CudaImage</code> <p>Optional buffer. Must match image size.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cache does not match the image dimensions.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>photoff/operations/filters.py</code> <pre><code>def apply_gaussian_blur(image: CudaImage,\n                        radius: float,\n                        image_copy_cache: CudaImage = None) -&gt; None:\n    \"\"\"\n    Applies a Gaussian blur effect to an image in-place.\n\n    Args:\n        image (CudaImage): Image to blur.\n        radius (float): Radius of the blur in pixels.\n        image_copy_cache (CudaImage, optional): Optional buffer. Must match image size.\n\n    Raises:\n        ValueError: If the cache does not match the image dimensions.\n\n    Returns:\n        None\n    \"\"\"\n\n    need_free = False\n    if image_copy_cache is None:\n        image_copy_cache = CudaImage(image.width, image.height)\n        copy_buffers_same_size(image_copy_cache.buffer, image.buffer, image.width, image.height)\n        need_free = True\n    else:\n        if (image_copy_cache.width != image.width or image_copy_cache.height != image.height):\n            raise ValueError(f\"El buffer auxiliar debe coincidir con las dimensiones de la imagen original: {image.width}x{image.height}, recibido {image_copy_cache.width}x{image_copy_cache.height}\")\n\n    _lib.apply_gaussian_blur(image.buffer, image_copy_cache.buffer, image.width, image.height, radius)\n\n    if need_free:\n        image_copy_cache.free()\n</code></pre>"},{"location":"api/#photoff.operations.filters.apply_grayscale","title":"<code>apply_grayscale(image)</code>","text":"<p>Converts an image to grayscale in-place using luminosity method.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>Image to convert.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>photoff/operations/filters.py</code> <pre><code>def apply_grayscale(image: CudaImage) -&gt; None:\n    \"\"\"\n    Converts an image to grayscale in-place using luminosity method.\n\n    Args:\n        image (CudaImage): Image to convert.\n\n    Returns:\n        None\n    \"\"\"\n\n    _lib.apply_grayscale(image.buffer, image.width, image.height)\n</code></pre>"},{"location":"api/#photoff.operations.filters.apply_opacity","title":"<code>apply_opacity(image, opacity)</code>","text":"<p>Modifies the alpha channel of an image to apply global opacity.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>Image to modify.</p> required <code>opacity</code> <code>float</code> <p>Opacity value between 0.0 (transparent) and 1.0 (opaque).</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>photoff/operations/filters.py</code> <pre><code>def apply_opacity(image: CudaImage, opacity: float) -&gt; None:\n    \"\"\"\n    Modifies the alpha channel of an image to apply global opacity.\n\n    Args:\n        image (CudaImage): Image to modify.\n        opacity (float): Opacity value between 0.0 (transparent) and 1.0 (opaque).\n\n    Returns:\n        None\n    \"\"\"\n\n    _lib.apply_opacity(image.buffer, image.width, image.height, opacity)\n</code></pre>"},{"location":"api/#photoff.operations.filters.apply_shadow","title":"<code>apply_shadow(image, radius, intensity, shadow_color, image_copy_cache=None, inner=False)</code>","text":"<p>Applies a shadow effect around the opaque regions of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>Image to apply the shadow to.</p> required <code>radius</code> <code>float</code> <p>Blur radius of the shadow.</p> required <code>intensity</code> <code>float</code> <p>Intensity multiplier of the shadow.</p> required <code>shadow_color</code> <code>RGBA</code> <p>Color of the shadow.</p> required <code>image_copy_cache</code> <code>CudaImage</code> <p>Optional image copy buffer. Must match original image size.</p> <code>None</code> <code>inner</code> <code>bool</code> <p>Whether to draw the shadow inside the shape. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cache does not match the image dimensions.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>photoff/operations/filters.py</code> <pre><code>def apply_shadow(image: CudaImage,\n                 radius: float,\n                 intensity: float,\n                 shadow_color: RGBA,\n                 image_copy_cache: CudaImage = None,\n                 inner: bool = False) -&gt; None:\n    \"\"\"\n    Applies a shadow effect around the opaque regions of an image.\n\n    Args:\n        image (CudaImage): Image to apply the shadow to.\n        radius (float): Blur radius of the shadow.\n        intensity (float): Intensity multiplier of the shadow.\n        shadow_color (RGBA): Color of the shadow.\n        image_copy_cache (CudaImage, optional): Optional image copy buffer. Must match original image size.\n        inner (bool, optional): Whether to draw the shadow inside the shape. Defaults to False.\n\n    Raises:\n        ValueError: If the cache does not match the image dimensions.\n\n    Returns:\n        None\n    \"\"\"\n\n    need_free = False\n    if image_copy_cache is None:\n        image_copy_cache = CudaImage(image.width, image.height)\n        copy_buffers_same_size(image_copy_cache.buffer, image.buffer, image.width, image.height)\n        need_free = True\n    else:\n        if (image_copy_cache.width != image.width or image_copy_cache.height != image.height):\n            raise ValueError(f\"Destination image dimensions must match original image dimensions: {image.width}x{image.height}, got {image_copy_cache.width}x{image_copy_cache.height}\")\n\n    _lib.apply_shadow(image.buffer,\n                      image_copy_cache.buffer,\n                      image.width,\n                      image.height,\n                      radius,\n                      intensity,\n                      shadow_color.r,\n                      shadow_color.g,\n                      shadow_color.b,\n                      shadow_color.a,\n                      int(inner),\n                      )\n\n    if need_free:\n        image_copy_cache.free()\n</code></pre>"},{"location":"api/#photoff.operations.filters.apply_stroke","title":"<code>apply_stroke(image, stroke_width, stroke_color, image_copy_cache=None, inner=True)</code>","text":"<p>Draws a stroke (outline) around the non-transparent areas of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>Image to which the stroke will be applied.</p> required <code>stroke_width</code> <code>int</code> <p>Width of the stroke in pixels.</p> required <code>stroke_color</code> <code>RGBA</code> <p>Color of the stroke.</p> required <code>image_copy_cache</code> <code>CudaImage</code> <p>Optional cache of the original image. Must match dimensions.</p> <code>None</code> <code>inner</code> <code>bool</code> <p>If True, stroke is drawn inside the shape; otherwise outside. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided cache does not match image dimensions.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>photoff/operations/filters.py</code> <pre><code>def apply_stroke(image: CudaImage,\n                 stroke_width: int,\n                 stroke_color: RGBA,\n                 image_copy_cache: CudaImage = None,\n                 inner: bool = True) -&gt; None:\n    \"\"\"\n    Draws a stroke (outline) around the non-transparent areas of an image.\n\n    Args:\n        image (CudaImage): Image to which the stroke will be applied.\n        stroke_width (int): Width of the stroke in pixels.\n        stroke_color (RGBA): Color of the stroke.\n        image_copy_cache (CudaImage, optional): Optional cache of the original image. Must match dimensions.\n        inner (bool, optional): If True, stroke is drawn inside the shape; otherwise outside. Defaults to True.\n\n    Raises:\n        ValueError: If the provided cache does not match image dimensions.\n\n    Returns:\n        None\n    \"\"\"\n\n    need_free = False\n    if image_copy_cache is None:\n        image_copy_cache = CudaImage(image.width, image.height)\n        copy_buffers_same_size(image_copy_cache.buffer, image.buffer, image.width, image.height)\n        need_free = True\n    else:\n        if (image_copy_cache.width != image.width or image_copy_cache.height != image.height):\n            raise ValueError(f\"Destination image dimensions must match original image dimensions: {image.width}x{image.height}, got {image_copy_cache.width}x{image_copy_cache.height}\")\n\n    _lib.apply_stroke(image.buffer,\n                      image_copy_cache.buffer,\n                      image.width,\n                      image.height,\n                      stroke_width,\n                      stroke_color.r,\n                      stroke_color.g,\n                      stroke_color.b,\n                      stroke_color.a,\n                      int(inner),\n                      )\n\n    if need_free:\n        image_copy_cache.free()\n</code></pre>"},{"location":"api/#photoff.operations.resize","title":"<code>photoff.operations.resize</code>","text":""},{"location":"api/#photoff.operations.resize.ResizeMethod","title":"<code>ResizeMethod</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing supported image resizing algorithms.</p> <p>Attributes:</p> Name Type Description <code>BILINEAR</code> <p>Bilinear interpolation (smooth, reasonably fast).</p> <code>NEAREST</code> <p>Nearest neighbor interpolation (fastest, lowest quality).</p> <code>BICUBIC</code> <p>Bicubic interpolation (higher quality, slower).</p> Usage <p>method = ResizeMethod.BICUBIC</p> Source code in <code>photoff/operations/resize.py</code> <pre><code>class ResizeMethod(Enum):\n    \"\"\"\n    Enum representing supported image resizing algorithms.\n\n    Attributes:\n        BILINEAR: Bilinear interpolation (smooth, reasonably fast).\n        NEAREST: Nearest neighbor interpolation (fastest, lowest quality).\n        BICUBIC: Bicubic interpolation (higher quality, slower).\n\n    Usage:\n        method = ResizeMethod.BICUBIC\n    \"\"\"\n    BILINEAR = \"bilinear\"\n    NEAREST = \"nearest\"\n    BICUBIC = \"bicubic\"\n</code></pre>"},{"location":"api/#photoff.operations.resize.crop_margins","title":"<code>crop_margins(image, left=0, top=0, right=0, bottom=0, crop_image_cache=None)</code>","text":"<p>Crops margins from the edges of a CudaImage.</p> <p>Margins are specified in pixels. The resulting image will be smaller and positioned relative to the top-left corner of the cropped area.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>The input image to crop.</p> required <code>left</code> <code>int</code> <p>Pixels to remove from the left edge. Defaults to 0.</p> <code>0</code> <code>top</code> <code>int</code> <p>Pixels to remove from the top edge. Defaults to 0.</p> <code>0</code> <code>right</code> <code>int</code> <p>Pixels to remove from the right edge. Defaults to 0.</p> <code>0</code> <code>bottom</code> <code>int</code> <p>Pixels to remove from the bottom edge. Defaults to 0.</p> <code>0</code> <code>crop_image_cache</code> <code>CudaImage</code> <p>Pre-allocated buffer for the cropped image. Must match the expected result dimensions.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>CudaImage</code> <code>CudaImage</code> <p>The cropped image.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any margin is negative.</p> <code>ValueError</code> <p>If margins exceed the image's size.</p> <code>ValueError</code> <p>If the cache image does not match the result size.</p> Example <p>cropped = crop_margins(img, left=10, top=10, right=10, bottom=10)</p> Source code in <code>photoff/operations/resize.py</code> <pre><code>def crop_margins(image: CudaImage,\n                 left: int = 0,\n                 top: int = 0,\n                 right: int = 0,\n                 bottom: int = 0,\n                 crop_image_cache: CudaImage = None,\n                 ) -&gt; CudaImage:\n    \"\"\"\n    Crops margins from the edges of a CudaImage.\n\n    Margins are specified in pixels. The resulting image will be smaller and positioned\n    relative to the top-left corner of the cropped area.\n\n    Args:\n        image (CudaImage): The input image to crop.\n        left (int, optional): Pixels to remove from the left edge. Defaults to 0.\n        top (int, optional): Pixels to remove from the top edge. Defaults to 0.\n        right (int, optional): Pixels to remove from the right edge. Defaults to 0.\n        bottom (int, optional): Pixels to remove from the bottom edge. Defaults to 0.\n        crop_image_cache (CudaImage, optional): Pre-allocated buffer for the cropped image.\n            Must match the expected result dimensions.\n\n    Returns:\n        CudaImage: The cropped image.\n\n    Raises:\n        ValueError: If any margin is negative.\n        ValueError: If margins exceed the image's size.\n        ValueError: If the cache image does not match the result size.\n\n    Example:\n        &gt;&gt;&gt; cropped = crop_margins(img, left=10, top=10, right=10, bottom=10)\n    \"\"\"\n\n    if left &lt; 0 or top &lt; 0 or right &lt; 0 or bottom &lt; 0:\n        raise ValueError(\"Margins cannot be negative\")\n\n    if left + right &gt;= image.width or top + bottom &gt;= image.height:\n        raise ValueError(\"Total margins exceed image dimensions\")\n\n    new_width = image.width - left - right\n    new_height = image.height - top - bottom\n\n    if crop_image_cache is None:\n        result = CudaImage(new_width, new_height)\n    else:\n        if crop_image_cache.width != new_width or crop_image_cache.height != new_height:\n            raise ValueError(f\"Destination image cache dimensions must match crop result: {new_width}x{new_height}\")\n        result = crop_image_cache\n\n    _lib.crop_image(result.buffer,\n                    image.buffer,\n                    image.width,\n                    image.height,\n                    new_width,\n                    new_height,\n                    left,\n                    top,\n                    )\n\n    return result\n</code></pre>"},{"location":"api/#photoff.operations.resize.resize","title":"<code>resize(image, width, height, method=ResizeMethod.BICUBIC, resize_image_cache=None)</code>","text":"<p>Resizes a CudaImage to the specified dimensions using the chosen interpolation method.</p> <p>Supports bilinear, nearest-neighbor, and bicubic resampling. A cache image can be reused for performance to avoid memory allocation.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>The input image to resize.</p> required <code>width</code> <code>int</code> <p>Target width.</p> required <code>height</code> <code>int</code> <p>Target height.</p> required <code>method</code> <code>ResizeMethod</code> <p>Resampling method. Defaults to BICUBIC.</p> <code>BICUBIC</code> <code>resize_image_cache</code> <code>CudaImage</code> <p>Pre-allocated image for the resized result. Must match target dimensions if provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>CudaImage</code> <code>CudaImage</code> <p>A new (or reused) image resized to the given dimensions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cache image dimensions do not match the target size.</p> <code>ValueError</code> <p>If the interpolation method is not supported.</p> Example <p>resized = resize(img, 256, 256, method=ResizeMethod.BILINEAR)</p> Source code in <code>photoff/operations/resize.py</code> <pre><code>def resize(image: CudaImage,\n           width: int,\n           height: int,\n           method: ResizeMethod = ResizeMethod.BICUBIC,\n           resize_image_cache: CudaImage = None,\n           ) -&gt; CudaImage:\n    \"\"\"\n    Resizes a CudaImage to the specified dimensions using the chosen interpolation method.\n\n    Supports bilinear, nearest-neighbor, and bicubic resampling. A cache image can be reused\n    for performance to avoid memory allocation.\n\n    Args:\n        image (CudaImage): The input image to resize.\n        width (int): Target width.\n        height (int): Target height.\n        method (ResizeMethod, optional): Resampling method. Defaults to BICUBIC.\n        resize_image_cache (CudaImage, optional): Pre-allocated image for the resized result.\n            Must match target dimensions if provided.\n\n    Returns:\n        CudaImage: A new (or reused) image resized to the given dimensions.\n\n    Raises:\n        ValueError: If the cache image dimensions do not match the target size.\n        ValueError: If the interpolation method is not supported.\n\n    Example:\n        &gt;&gt;&gt; resized = resize(img, 256, 256, method=ResizeMethod.BILINEAR)\n    \"\"\"\n\n    if resize_image_cache is None:\n        result = CudaImage(width, height)\n    else:\n        if resize_image_cache.width != width or resize_image_cache.height != height:\n            raise ValueError(f\"Destination image dimensions must match resize dimensions: {width}x{height}, got {resize_image_cache.width}x{resize_image_cache.height}\")\n        result = resize_image_cache\n\n    if method == ResizeMethod.BILINEAR:\n        _lib.resize_bilinear(result.buffer, image.buffer, width, height, image.width, image.height)\n    elif method == ResizeMethod.NEAREST:\n        _lib.resize_nearest(result.buffer, image.buffer, width, height, image.width, image.height)\n    elif method == ResizeMethod.BICUBIC:\n        _lib.resize_bicubic(result.buffer, image.buffer, width, height, image.width, image.height)\n    else:\n        raise ValueError(f\"Unsupported resize method: {method}\")\n\n    return result\n</code></pre>"},{"location":"api/#photoff.operations.text","title":"<code>photoff.operations.text</code>","text":""},{"location":"api/#photoff.operations.text.render_text","title":"<code>render_text(text, font_path, font_size=24, color=RGBA(0, 0, 0, 255))</code>","text":"<p>Renders a string of text into a CudaImage using a specified TrueType font.</p> <p>The function uses Pillow (PIL) to rasterize the text and transfers the resulting RGBA image into GPU memory as a <code>CudaImage</code>. Font metrics are computed to fit the rendered text exactly, avoiding unnecessary padding.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The string to render.</p> required <code>font_path</code> <code>str</code> <p>Path to a TrueType (.ttf) or OpenType (.otf) font file.</p> required <code>font_size</code> <code>int</code> <p>Font size in points. Defaults to 24.</p> <code>24</code> <code>color</code> <code>RGBA</code> <p>Text color. Defaults to opaque black (0, 0, 0, 255).</p> <code>RGBA(0, 0, 0, 255)</code> <p>Returns:</p> Name Type Description <code>CudaImage</code> <code>CudaImage</code> <p>GPU image containing the rendered text.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the font file cannot be loaded.</p> Example <p>img = render_text(\"Hello GPU!\", \"/fonts/Roboto-Regular.ttf\", 32, RGBA(255, 255, 255, 255))</p> Source code in <code>photoff/operations/text.py</code> <pre><code>def render_text(text: str,\n                font_path: str,\n                font_size: int = 24,\n                color: RGBA = RGBA(0, 0, 0, 255)\n                ) -&gt; CudaImage:\n    \"\"\"\n    Renders a string of text into a CudaImage using a specified TrueType font.\n\n    The function uses Pillow (PIL) to rasterize the text and transfers the resulting\n    RGBA image into GPU memory as a `CudaImage`. Font metrics are computed to fit\n    the rendered text exactly, avoiding unnecessary padding.\n\n    Args:\n        text (str): The string to render.\n        font_path (str): Path to a TrueType (.ttf) or OpenType (.otf) font file.\n        font_size (int, optional): Font size in points. Defaults to 24.\n        color (RGBA, optional): Text color. Defaults to opaque black (0, 0, 0, 255).\n\n    Returns:\n        CudaImage: GPU image containing the rendered text.\n\n    Raises:\n        ValueError: If the font file cannot be loaded.\n\n    Example:\n        &gt;&gt;&gt; img = render_text(\"Hello GPU!\", \"/fonts/Roboto-Regular.ttf\", 32, RGBA(255, 255, 255, 255))\n    \"\"\"\n\n    try:\n        font = ImageFont.truetype(font_path, font_size)\n    except Exception as e:\n        raise ValueError(f\"Error al cargar la fuente '{font_path}': {e}\")\n\n    temp_img = Image.new(\"RGBA\", (1, 1))\n    temp_draw = ImageDraw.Draw(temp_img)\n\n    try:\n        bbox = font.getbbox(text)\n    except AttributeError:\n        bbox = temp_draw.textbbox((0, 0), text, font=font)\n\n    left, top, right, bottom = bbox\n    text_width = right - left\n    text_height = bottom - top\n\n    pil_image = Image.new(\"RGBA\", (text_width, text_height), (0, 0, 0, 0))\n    draw = ImageDraw.Draw(pil_image)\n\n    color_tuple = (color.r, color.g, color.b, color.a)\n    draw.text((-left, -top), text, fill=color_tuple, font=font)\n\n    cuda_image = CudaImage(text_width, text_height)\n\n    img_array = np.asarray(pil_image, dtype=np.uint8)\n    c_buffer = ffi.cast(\"uchar4*\", img_array.ctypes.data)\n    copy_to_device(cuda_image.buffer, c_buffer, text_width, text_height)\n\n    return cuda_image\n</code></pre>"},{"location":"api/#photoff.operations.utils","title":"<code>photoff.operations.utils</code>","text":""},{"location":"api/#photoff.operations.utils.blend_aligned","title":"<code>blend_aligned(background, image, align='center', offset_x=0, offset_y=0)</code>","text":"<p>Blends an image onto a background at a specified alignment and optional offset.</p> <p>The image is positioned relative to the background based on the <code>align</code> parameter, which supports standard alignment strings (e.g., \"center\", \"top-left\", etc.). Offsets can be applied to adjust the final position.</p> <p>Parameters:</p> Name Type Description Default <code>background</code> <code>CudaImage</code> <p>The background image where the input image will be blended.</p> required <code>image</code> <code>CudaImage</code> <p>The image to blend.</p> required <code>align</code> <code>str</code> <p>Alignment method. Supported values: - \"center\" / \"middle\" - \"top\", \"bottom\", \"left\", \"right\" - \"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\" Defaults to \"center\".</p> <code>'center'</code> <code>offset_x</code> <code>int</code> <p>Horizontal pixel offset to apply after alignment. Defaults to 0.</p> <code>0</code> <code>offset_y</code> <code>int</code> <p>Vertical pixel offset to apply after alignment. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>blend_aligned(bg, img, align=\"bottom-right\", offset_x=-10, offset_y=-10)</p> Source code in <code>photoff/operations/utils.py</code> <pre><code>def blend_aligned(background: CudaImage,\n                  image: CudaImage,\n                  align: str = \"center\",\n                  offset_x: int = 0,\n                  offset_y: int = 0,\n                  ) -&gt; None:\n    \"\"\"\n    Blends an image onto a background at a specified alignment and optional offset.\n\n    The image is positioned relative to the background based on the `align` parameter,\n    which supports standard alignment strings (e.g., \"center\", \"top-left\", etc.).\n    Offsets can be applied to adjust the final position.\n\n    Args:\n        background (CudaImage): The background image where the input image will be blended.\n        image (CudaImage): The image to blend.\n        align (str, optional): Alignment method. Supported values:\n            - \"center\" / \"middle\"\n            - \"top\", \"bottom\", \"left\", \"right\"\n            - \"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"\n            Defaults to \"center\".\n        offset_x (int, optional): Horizontal pixel offset to apply after alignment. Defaults to 0.\n        offset_y (int, optional): Vertical pixel offset to apply after alignment. Defaults to 0.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; blend_aligned(bg, img, align=\"bottom-right\", offset_x=-10, offset_y=-10)\n    \"\"\"\n\n    if align == \"center\" or align == \"middle\":\n        x = (background.width - image.width) // 2\n        y = (background.height - image.height) // 2\n\n    elif align == \"top\":\n        x = (background.width - image.width) // 2\n        y = 0\n\n    elif align == \"bottom\":\n        x = (background.width - image.width) // 2\n        y = background.height - image.height\n\n    elif align == \"left\":\n        x = 0\n        y = (background.height - image.height) // 2\n\n    elif align == \"right\":\n        x = background.width - image.width\n        y = (background.height - image.height) // 2\n\n    elif align == \"top-left\":\n        x = 0\n        y = 0\n\n    elif align == \"top-right\":\n        x = background.width - image.width\n        y = 0\n\n    elif align == \"bottom-left\":\n        x = 0\n        y = background.height - image.height\n\n    elif align == \"bottom-right\":\n        x = background.width - image.width\n        y = background.height - image.height\n\n    else:\n        x = (background.width - image.width) // 2\n        y = (background.height - image.height) // 2\n\n    x += offset_x\n    y += offset_y\n\n    blend(background, image, x, y)\n</code></pre>"},{"location":"api/#photoff.operations.utils.cover_image_in_container","title":"<code>cover_image_in_container(image, container_width, container_height, offset_x=0, offset_y=0, background_color=RGBA(0, 0, 0, 0), container_image_cache=None, resize_image_cache=None, resize_mode=ResizeMethod.BICUBIC)</code>","text":"<p>Resizes an image to fully cover a container while maintaining aspect ratio, and blends it centered (or offset) within the container.</p> <p>The image is scaled up proportionally so that it completely fills the container dimensions (<code>container_width</code> x <code>container_height</code>). The resized image may overflow on one axis, similar to CSS's <code>background-size: cover</code>. Optional caching and resizing method are supported for performance and quality tuning.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>The input image to be resized and placed.</p> required <code>container_width</code> <code>int</code> <p>Width of the container image.</p> required <code>container_height</code> <code>int</code> <p>Height of the container image.</p> required <code>offset_x</code> <code>int</code> <p>Horizontal offset to apply after centering. Defaults to 0.</p> <code>0</code> <code>offset_y</code> <code>int</code> <p>Vertical offset to apply after centering. Defaults to 0.</p> <code>0</code> <code>background_color</code> <code>RGBA</code> <p>Background color to fill the container. Defaults to transparent black.</p> <code>RGBA(0, 0, 0, 0)</code> <code>container_image_cache</code> <code>CudaImage</code> <p>Pre-allocated container image buffer. Must match the container dimensions.</p> <code>None</code> <code>resize_image_cache</code> <code>CudaImage</code> <p>Pre-allocated image for resized content. Must match computed resize dimensions.</p> <code>None</code> <code>resize_mode</code> <code>ResizeMethod</code> <p>Resize algorithm to use (e.g., BICUBIC, NEAREST). Defaults to BICUBIC.</p> <code>BICUBIC</code> <p>Returns:</p> Name Type Description <code>CudaImage</code> <code>CudaImage</code> <p>A new image with the resized input blended over the background.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the number of images exceeds the grid capacity.</p> <code>ValueError</code> <p>If provided <code>resize_image_cache</code> or <code>container_image_cache</code> have incorrect dimensions.</p> Source code in <code>photoff/operations/utils.py</code> <pre><code>def cover_image_in_container(image: CudaImage,\n                             container_width: int,\n                             container_height: int,\n                             offset_x: int = 0,\n                             offset_y: int = 0,\n                             background_color: RGBA = RGBA(0, 0, 0, 0),\n                             container_image_cache: CudaImage = None,\n                             resize_image_cache: CudaImage = None,\n                             resize_mode: ResizeMethod = ResizeMethod.BICUBIC,\n                             ) -&gt; CudaImage:\n    \"\"\"\n    Resizes an image to fully cover a container while maintaining aspect ratio,\n    and blends it centered (or offset) within the container.\n\n    The image is scaled up proportionally so that it completely fills the container\n    dimensions (`container_width` x `container_height`). The resized image may overflow\n    on one axis, similar to CSS's `background-size: cover`. Optional caching and\n    resizing method are supported for performance and quality tuning.\n\n    Args:\n        image (CudaImage): The input image to be resized and placed.\n        container_width (int): Width of the container image.\n        container_height (int): Height of the container image.\n        offset_x (int, optional): Horizontal offset to apply after centering. Defaults to 0.\n        offset_y (int, optional): Vertical offset to apply after centering. Defaults to 0.\n        background_color (RGBA, optional): Background color to fill the container. Defaults to transparent black.\n        container_image_cache (CudaImage, optional): Pre-allocated container image buffer. Must match the container dimensions.\n        resize_image_cache (CudaImage, optional): Pre-allocated image for resized content. Must match computed resize dimensions.\n        resize_mode (ResizeMethod, optional): Resize algorithm to use (e.g., BICUBIC, NEAREST). Defaults to BICUBIC.\n\n    Returns:\n        CudaImage: A new image with the resized input blended over the background.\n\n    Raises:\n        ValueError: If the number of images exceeds the grid capacity.\n        ValueError: If provided `resize_image_cache` or `container_image_cache` have incorrect dimensions.\n    \"\"\"\n    scale = max(container_width / image.width, container_height / image.height)\n    new_width = int(image.width * scale)\n    new_height = int(image.height * scale)\n\n    need_free_resized = False\n    if resize_image_cache is None:\n        resized_image = CudaImage(new_width, new_height)\n        need_free_resized = True\n    else:\n        if (resize_image_cache.width != new_width or resize_image_cache.height != new_height):\n            raise ValueError(f\"Resize cache dimensions must match: {new_width}x{new_height}, got {resize_image_cache.width}x{resize_image_cache.height}\")\n        resized_image = resize_image_cache\n\n    resize(image,\n           new_width,\n           new_height,\n           method=resize_mode,\n           resize_image_cache=resized_image,\n           )\n\n    if container_image_cache is None:\n        container = CudaImage(container_width, container_height)\n    else:\n        if (container_image_cache.width != container_width or container_image_cache.height != container_height):\n            raise ValueError(f\"Container cache dimensions must match: {container_width}x{container_height}, got {container_image_cache.width}x{container_image_cache.height}\")\n        container = container_image_cache\n\n    fill_color(container, background_color)\n\n    x = (container_width - new_width) // 2 + offset_x\n    y = (container_height - new_height) // 2 + offset_y\n\n    blend(container, resized_image, x, y)\n\n    if need_free_resized:\n        resized_image.free()\n\n    return container\n</code></pre>"},{"location":"api/#photoff.operations.utils.create_image_collage","title":"<code>create_image_collage(images, grid_width, grid_height, spacing=0, background_color=RGBA(0, 0, 0, 0), collage_image_cache=None)</code>","text":"<p>Creates a collage from a list of CUDA images arranged in a grid.</p> <p>All images must have identical dimensions. The function supports optional spacing between images and a custom background color. It also allows reuse of a pre-allocated image buffer to avoid reallocations.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>list[CudaImage]</code> <p>List of images to include in the collage.</p> required <code>grid_width</code> <code>int</code> <p>Number of columns in the collage grid.</p> required <code>grid_height</code> <code>int</code> <p>Number of rows in the collage grid.</p> required <code>spacing</code> <code>int</code> <p>Space in pixels between images in the grid. Defaults to 0.</p> <code>0</code> <code>background_color</code> <code>RGBA</code> <p>Background color to fill the collage. Defaults to transparent black (0, 0, 0, 0).</p> <code>RGBA(0, 0, 0, 0)</code> <code>collage_image_cache</code> <code>CudaImage</code> <p>Optional pre-allocated image to use as the collage buffer. Must match the final dimensions. If not provided, a new image will be created.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>CudaImage</code> <code>CudaImage</code> <p>A new image containing the collage.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the number of images exceeds the grid capacity.</p> <code>ValueError</code> <p>If input images do not have the same dimensions.</p> <code>ValueError</code> <p>If the provided collage_image_cache does not match the required dimensions.</p> Source code in <code>photoff/operations/utils.py</code> <pre><code>def create_image_collage(images: list[CudaImage],\n                         grid_width: int,\n                         grid_height: int,\n                         spacing: int = 0,\n                         background_color: RGBA = RGBA(0, 0, 0, 0),\n                         collage_image_cache: CudaImage = None,\n                         ) -&gt; CudaImage:\n    \"\"\"\n    Creates a collage from a list of CUDA images arranged in a grid.\n\n    All images must have identical dimensions. The function supports optional\n    spacing between images and a custom background color. It also allows\n    reuse of a pre-allocated image buffer to avoid reallocations.\n\n    Args:\n        images (list[CudaImage]): List of images to include in the collage.\n        grid_width (int): Number of columns in the collage grid.\n        grid_height (int): Number of rows in the collage grid.\n        spacing (int, optional): Space in pixels between images in the grid. Defaults to 0.\n        background_color (RGBA, optional): Background color to fill the collage. Defaults to transparent black (0, 0, 0, 0).\n        collage_image_cache (CudaImage, optional): Optional pre-allocated image to use as the collage buffer.\n            Must match the final dimensions. If not provided, a new image will be created.\n\n    Returns:\n        CudaImage: A new image containing the collage.\n\n    Raises:\n        ValueError: If the number of images exceeds the grid capacity.\n        ValueError: If input images do not have the same dimensions.\n        ValueError: If the provided collage_image_cache does not match the required dimensions.\n    \"\"\"\n\n    total_cells = grid_width * grid_height\n    num_images = len(images)\n    if num_images &gt; total_cells:\n        raise ValueError(f\"Number of images ({num_images}) exceeds grid capacity ({total_cells})\")\n\n    first = images[0]\n    img_w, img_h = first.width, first.height\n    for img in images:\n        if img.width != img_w or img.height != img_h:\n            raise ValueError(\"All images must have the same dimensions to form a uniform collage\")\n\n    width = (img_w * grid_width) + (spacing * (grid_width - 1))\n    height = (img_h * grid_height) + (spacing * (grid_height - 1))\n\n    if collage_image_cache is None:\n        result = CudaImage(width, height)\n    else:\n        if (collage_image_cache.width != width or collage_image_cache.height != height):\n            raise ValueError(f\"Collage cache dimensions must match: {width}x{height}, got {collage_image_cache.width}x{collage_image_cache.height}\")\n        result = collage_image_cache\n\n    fill_color(result, background_color)\n\n    for idx, img in enumerate(images):\n        col = idx % grid_width\n        row = idx // grid_width\n        x_pos = col * (img_w + spacing)\n        y_pos = row * (img_h + spacing)\n        blend(result, img, x_pos, y_pos)\n\n    return result\n</code></pre>"},{"location":"api/#photoff.operations.utils.create_image_grid","title":"<code>create_image_grid(image, grid_width, grid_height, num_images, spacing=0, background_color=RGBA(0, 0, 0, 0), grid_image_cache=None)</code>","text":"<p>Creates a grid layout by duplicating a single image multiple times.</p> <p>The image is repeated <code>num_images</code> times and arranged in a grid with the specified width and height. Optional spacing and background color can be configured. A cached output image can be reused for efficiency.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>The image to be repeated across the grid.</p> required <code>grid_width</code> <code>int</code> <p>Number of columns in the grid.</p> required <code>grid_height</code> <code>int</code> <p>Number of rows in the grid.</p> required <code>num_images</code> <code>int</code> <p>Total number of image copies to include in the grid. Must not exceed grid capacity.</p> required <code>spacing</code> <code>int</code> <p>Number of pixels between images in both directions. Defaults to 0.</p> <code>0</code> <code>background_color</code> <code>RGBA</code> <p>Background color to fill empty areas. Defaults to transparent black.</p> <code>RGBA(0, 0, 0, 0)</code> <code>grid_image_cache</code> <code>CudaImage</code> <p>Pre-allocated image buffer to use. Must match final grid size if provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>CudaImage</code> <code>CudaImage</code> <p>A new image containing the grid of repeated images.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>num_images</code> exceeds the grid's capacity.</p> <code>ValueError</code> <p>If <code>grid_image_cache</code> is provided but has incorrect dimensions.</p> Source code in <code>photoff/operations/utils.py</code> <pre><code>def create_image_grid(image: CudaImage,\n                      grid_width: int,\n                      grid_height: int,\n                      num_images: int,\n                      spacing: int = 0,\n                      background_color: RGBA = RGBA(0, 0, 0, 0),\n                      grid_image_cache: CudaImage = None,\n                      ) -&gt; CudaImage:\n    \"\"\"\n    Creates a grid layout by duplicating a single image multiple times.\n\n    The image is repeated `num_images` times and arranged in a grid with the specified\n    width and height. Optional spacing and background color can be configured. A cached\n    output image can be reused for efficiency.\n\n    Args:\n        image (CudaImage): The image to be repeated across the grid.\n        grid_width (int): Number of columns in the grid.\n        grid_height (int): Number of rows in the grid.\n        num_images (int): Total number of image copies to include in the grid. Must not exceed grid capacity.\n        spacing (int, optional): Number of pixels between images in both directions. Defaults to 0.\n        background_color (RGBA, optional): Background color to fill empty areas. Defaults to transparent black.\n        grid_image_cache (CudaImage, optional): Pre-allocated image buffer to use. Must match final grid size if provided.\n\n    Returns:\n        CudaImage: A new image containing the grid of repeated images.\n\n    Raises:\n        ValueError: If `num_images` exceeds the grid's capacity.\n        ValueError: If `grid_image_cache` is provided but has incorrect dimensions.\n    \"\"\"\n\n    total_cells = grid_width * grid_height\n    if num_images &gt; total_cells:\n        raise ValueError(f\"Number of images ({num_images}) exceeds grid capacity ({total_cells})\")\n\n    width = (image.width * grid_width) + (spacing * (grid_width - 1))\n    height = (image.height * grid_height) + (spacing * (grid_height - 1))\n\n    if grid_image_cache is None:\n        result = CudaImage(width, height)\n    else:\n        if grid_image_cache.width != width or grid_image_cache.height != height:\n            raise ValueError(f\"Grid cache dimensions must match: {width}x{height}, got {grid_image_cache.width}x{grid_image_cache.height}\")\n        result = grid_image_cache\n\n    fill_color(result, background_color)\n\n    count = 0\n    for y in range(grid_height):\n        for x in range(grid_width):\n            if count &gt;= num_images:\n                break\n\n            pos_x = x * (image.width + spacing)\n            pos_y = y * (image.height + spacing)\n\n            blend(result, image, pos_x, pos_y)\n\n            count += 1\n\n        if count &gt;= num_images:\n            break\n\n    return result\n</code></pre>"},{"location":"api/#photoff.operations.utils.get_cover_resize_dimensions","title":"<code>get_cover_resize_dimensions(image, container_width, container_height)</code>","text":"<p>Calculates the new dimensions to resize an image so that it fully covers a container while preserving its aspect ratio.</p> <p>The resulting dimensions ensure that the image completely fills the target container (<code>container_width</code> x <code>container_height</code>), potentially exceeding one of the container's dimensions. This mimics the behavior of <code>background-size: cover</code> in CSS.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>The original image to be resized.</p> required <code>container_width</code> <code>int</code> <p>Target container width.</p> required <code>container_height</code> <code>int</code> <p>Target container height.</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: The new width and height that the image should be resized to.</p> Example <p>get_cover_resize_dimensions(img, 1920, 1080) (1920, 1280)</p> Source code in <code>photoff/operations/utils.py</code> <pre><code>def get_cover_resize_dimensions(image: CudaImage,\n                                container_width: int,\n                                container_height: int) -&gt; tuple[int, int]:\n    \"\"\"\n    Calculates the new dimensions to resize an image so that it fully covers\n    a container while preserving its aspect ratio.\n\n    The resulting dimensions ensure that the image completely fills the target\n    container (`container_width` x `container_height`), potentially exceeding\n    one of the container's dimensions. This mimics the behavior of `background-size: cover` in CSS.\n\n    Args:\n        image (CudaImage): The original image to be resized.\n        container_width (int): Target container width.\n        container_height (int): Target container height.\n\n    Returns:\n        tuple[int, int]: The new width and height that the image should be resized to.\n\n    Example:\n        &gt;&gt;&gt; get_cover_resize_dimensions(img, 1920, 1080)\n        (1920, 1280)\n    \"\"\"\n\n    scale = max(container_width / image.width, container_height / image.height)\n    new_width = int(image.width * scale)\n    new_height = int(image.height * scale)\n\n    return new_width, new_height\n</code></pre>"},{"location":"api/#photoff.operations.utils.get_no_padding_size","title":"<code>get_no_padding_size(image, padding)</code>","text":"<p>Calculates the size of an image after removing equal padding from all sides.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>The padded image.</p> required <code>padding</code> <code>int</code> <p>Padding in pixels to remove from each side.</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: The resulting width and height without padding.</p> Example <p>get_no_padding_size(img, 10) (image.width - 20, image.height - 20)</p> Source code in <code>photoff/operations/utils.py</code> <pre><code>def get_no_padding_size(image: CudaImage, padding: int) -&gt; tuple[int, int]:\n    \"\"\"\n    Calculates the size of an image after removing equal padding from all sides.\n\n    Args:\n        image (CudaImage): The padded image.\n        padding (int): Padding in pixels to remove from each side.\n\n    Returns:\n        tuple[int, int]: The resulting width and height without padding.\n\n    Example:\n        &gt;&gt;&gt; get_no_padding_size(img, 10)\n        (image.width - 20, image.height - 20)\n    \"\"\"\n    return image.width - (padding * 2), image.height - (padding * 2)\n</code></pre>"},{"location":"api/#photoff.operations.utils.get_padding_size","title":"<code>get_padding_size(image, padding)</code>","text":"<p>Calculates the size of an image after adding equal padding on all sides.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>CudaImage</code> <p>The original image.</p> required <code>padding</code> <code>int</code> <p>Padding in pixels to add on each side.</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: The new width and height including padding.</p> Example <p>get_padding_size(img, 10) (image.width + 20, image.height + 20)</p> Source code in <code>photoff/operations/utils.py</code> <pre><code>def get_padding_size(image: CudaImage, padding: int) -&gt; tuple[int, int]:\n    \"\"\"\n    Calculates the size of an image after adding equal padding on all sides.\n\n    Args:\n        image (CudaImage): The original image.\n        padding (int): Padding in pixels to add on each side.\n\n    Returns:\n        tuple[int, int]: The new width and height including padding.\n\n    Example:\n        &gt;&gt;&gt; get_padding_size(img, 10)\n        (image.width + 20, image.height + 20)\n    \"\"\"\n    return image.width + (padding * 2), image.height + (padding * 2)\n</code></pre>"},{"location":"basics/","title":"PhotoFF Basics","text":"<p>This guide covers the fundamental concepts and operations of the PhotoFF library. After reading this, you'll understand how to load, manipulate, and save images using GPU acceleration.</p>"},{"location":"basics/#core-concepts","title":"Core Concepts","text":""},{"location":"basics/#cudaimage","title":"CudaImage","text":"<p>The <code>CudaImage</code> class is the central object in PhotoFF. It represents an image stored in GPU memory as a RGBA buffer.</p> <p>Note: <code>CudaImage</code> does not guarantee that the newly reserved GPU memory is zero\u2011initialized. If you plan to use the image as a fully transparent background, clear it right after allocation:</p> <pre><code>from photoff.core.types import CudaImage, RGBA\nfrom photoff.operations.fill import fill_color\n\nimage = CudaImage(800, 600)\nfill_color(image, RGBA(0, 0, 0, 0))  # Ensure full transparency\n</code></pre> <pre><code>from photoff.core.types import CudaImage\n\n# Reserving GPU memory for an 800x600 image\nimage = CudaImage(800, 600)\n\n# Free the image from GPU memory when done\nimage.free()\n</code></pre>"},{"location":"basics/#rgba","title":"RGBA","text":"<p>PhotoFF uses the RGBA color model (Red, Green, Blue, Alpha) for all operations:</p> <pre><code>from photoff.core.types import RGBA\n\n# Create colors\nred = RGBA(255, 0, 0, 255)         # Solid red\nblue = RGBA(0, 0, 255, 255)        # Solid blue\nsemi_transparent = RGBA(0, 255, 0, 128)  # Semi-transparent green\ntransparent = RGBA(0, 0, 0, 0)     # Completely transparent\n</code></pre>"},{"location":"basics/#basic-operations","title":"Basic Operations","text":""},{"location":"basics/#loading-and-saving-images","title":"Loading and Saving Images","text":"<p>To load images from disk and save them back:</p> <pre><code>from photoff.io import load_image, save_image\nfrom photoff.core.types import CudaImage\n\n# Load an image from disk into GPU memory\nimage = load_image(\"input.jpg\")\n\n# Save an image to disk\nsave_image(image, \"output.png\")\n\n# Free the image from GPU memory\nimage.free()\n</code></pre>"},{"location":"basics/#image-filling","title":"Image Filling","text":"<p>Fill an image with a solid color or gradient:</p> <pre><code>from photoff.operations.fill import fill_color, fill_gradient\nfrom photoff.core.types import CudaImage, RGBA\n\n# Create and fill with solid color\nimage = CudaImage(400, 300)\nfill_color(image, RGBA(255, 0, 0, 255))  # Fill with red\n\n# Fill with gradient\nstart_color = RGBA(255, 0, 0, 255)  # Red\nend_color = RGBA(0, 0, 255, 255)    # Blue\ndirection = 0  # 0: horizontal, 1: vertical, 2: diagonal, 3: radial\nseamless = False\nfill_gradient(image, start_color, end_color, direction, seamless)\n\n# Free the image from GPU memory\nimage.free()\n</code></pre>"},{"location":"basics/#applying-filters","title":"Applying Filters","text":"<p>PhotoFF offers various filters to modify images:</p> <pre><code>from photoff.operations.filters import apply_gaussian_blur, apply_corner_radius, apply_grayscale\nfrom photoff.io import load_image, save_image\n\n# Load an image\nimage = load_image(\"input.jpg\")\n\n# Apply a Gaussian blur\napply_gaussian_blur(image, radius=5.0)\n\n# Round the corners\napply_corner_radius(image, size=20)\n\n# Convert to grayscale\napply_grayscale(image)\n\n# Save the result\nsave_image(image, \"filtered.png\")\n\n# Free the image from GPU memory\nimage.free()\n</code></pre>"},{"location":"basics/#resizing-images","title":"Resizing Images","text":"<p>Resize images with different interpolation methods:</p> <pre><code>from photoff.operations.resize import resize, ResizeMethod\nfrom photoff.io import load_image, save_image\n\n# Load an image\nimage = load_image(\"input.jpg\")\n\n# Resize to 400x300 using bicubic interpolation\nresized = resize(image, 400, 300, method=ResizeMethod.BICUBIC)\n\n# Save the result\nsave_image(resized, \"resized.png\")\n\n# Free both images\nimage.free()\nresized.free()\n</code></pre>"},{"location":"basics/#blending-images","title":"Blending Images","text":"<p>Combine multiple images together:</p> <pre><code>from photoff.operations.blend import blend\nfrom photoff.io import load_image, save_image\nfrom photoff.core.types import CudaImage, RGBA\nfrom photoff.operations.fill import fill_color\n\n# Create a background\nbackground = CudaImage(800, 600)\nfill_color(background, RGBA(200, 200, 200, 255))  # Light gray\n\n# Load a foreground image\nforeground = load_image(\"logo.png\")\n\n# Blend the foreground onto the background at position (100, 100)\nblend(background, foreground, 100, 100)\n\n# Save the result\nsave_image(background, \"blended.png\")\n\n# Free the images from GPU memory\nbackground.free()\nforeground.free()\n</code></pre>"},{"location":"basics/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, you can:</p> <ul> <li>Explore the Advanced Topics for more memory management and performance tips</li> <li>Check the API Reference for detailed information on all functions</li> </ul>"},{"location":"installation/","title":"PhotoFF Installation Guide (Linux &amp; Windows)","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing PhotoFF, ensure you have the following prerequisites:</p> <ul> <li>Python 3.9 or newer</li> <li>NVIDIA GPU with CUDA support</li> <li>CUDA Toolkit 11.0 or newer \u2013 Required for compiling the CUDA components</li> <li>CFFI \u2013 Used for interfacing between Python and the CUDA library</li> <li>Pillow \u2013 Used for image loading, saving, and text rendering</li> <li>NumPy \u2013 Used for memory management when transferring image data to/from CUDA</li> </ul>"},{"location":"installation/#python-dependencies","title":"Python Dependencies","text":"<p>Install the required Python packages:</p> <pre><code>pip install cffi pillow numpy\n</code></pre>"},{"location":"installation/#installing-cuda-toolkit","title":"Installing CUDA Toolkit","text":"<ol> <li>Download the CUDA Toolkit from the NVIDIA Developer website</li> <li>Follow the instructions for your OS (Linux or Windows)</li> <li>Ensure <code>nvcc</code> is accessible:    <pre><code>nvcc --version\n</code></pre></li> </ol>"},{"location":"installation/#compiling-the-cuda-library","title":"Compiling the CUDA Library","text":""},{"location":"installation/#for-linux","title":"\ud83d\udc27 For Linux:","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/offerrall/photoff.git\ncd photoff\n</code></pre></p> </li> <li> <p>Compile the <code>.so</code> shared object:    <pre><code>python3 photoff_cuda_src/compile_linux.py\n</code></pre></p> </li> <li> <p>You\u2019ll get <code>photoff.so</code>.</p> </li> <li> <p>Make it available system-wide:</p> </li> </ol> <p>Option A: Temporary <pre><code>export LD_LIBRARY_PATH=/your/path/photoff:$LD_LIBRARY_PATH\n</code></pre></p> <p>Option B: Permanent    Add to <code>~/.bashrc</code> or <code>~/.zshrc</code>:    <pre><code>export LD_LIBRARY_PATH=/your/path/photoff:$LD_LIBRARY_PATH\nsource ~/.bashrc\n</code></pre></p> <p>Option C: System-wide <pre><code>echo \"/your/path/photoff\" | sudo tee /etc/ld.so.conf.d/photoff.conf\nsudo ldconfig\n</code></pre></p>"},{"location":"installation/#for-windows","title":"\ud83e\ude9f For Windows:","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/offerrall/photoff.git\ncd photoff\n</code></pre></p> </li> <li> <p>Compile the <code>.dll</code> using:    <pre><code>python photoff_cuda_src/compile_windows.py\n</code></pre></p> </li> <li> <p>Add the folder containing <code>photoff.dll</code> to your system PATH:</p> </li> <li>Search for \u201cEnvironment Variables\u201d in the Start menu</li> <li>Edit the PATH variable, and add the folder path</li> <li>Restart your terminal or IDE</li> </ol>"},{"location":"installation/#installing-the-python-package","title":"Installing the Python Package","text":"<p>Run this in the root of the project (after compilation):</p> <pre><code>pip install .\n</code></pre>"},{"location":"installation/#verifying-the-installation","title":"Verifying the Installation","text":"<p>Test your installation with the following Python script:</p> <pre><code>from photoff.operations.fill import fill_color\nfrom photoff.io import save_image\nfrom photoff.core.types import CudaImage, RGBA\n\n# Create a 200x200 red square\nimg = CudaImage(200, 200)\nfill_color(img, RGBA(255, 0, 0, 255))\nsave_image(img, \"red_square.png\")\nimg.free()\n\nprint(\"Installation successful!\")\n</code></pre> <p>If you see the image <code>red_square.png</code> and the message \u201cInstallation successful!\u201d, your setup is working.</p>"},{"location":"installation/#notes","title":"Notes","text":"<ul> <li>CFFI will load the appropriate file based on your OS</li> </ul>"},{"location":"installation/#license","title":"License","text":"<p>PhotoFF is distributed under the MIT license.</p>"}]}