{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Start","text":"<p>PhotoFF is a high-performance image processing library that uses CUDA to achieve exceptional processing speeds. Designed to maximize performance through efficient GPU memory management.</p>"},{"location":"#basic-example","title":"Basic Example","text":"<pre><code>from photoff.operations.filters import apply_gaussian_blur, apply_corner_radius\nfrom photoff.io import save_image, load_image\nfrom photoff import CudaImage\n\n# Load the image in GPU memory\nsrc_image: CudaImage = load_image(\"./assets/stock.jpg\")\n\n# Apply filters\napply_gaussian_blur(src_image, radius=5.0)\napply_corner_radius(src_image, size=200)\n\n# Save the result\nsave_image(src_image, \"./assets/gaussian_blur_test.png\")\n\n# Free the image from GPU memory\nsrc_image.free()\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Pythonic Interface: Clean, intuitive API designed for both beginners and advanced users</li> <li>Robust Image Manipulation: Comprehensive suite of operations including filters, transforms, and compositing</li> <li>Seamless Integration: Works with common image formats through PIL interoperability</li> <li>CUDA-Accelerated Processing: Harness the power of your GPU for blazing-fast image operations</li> <li>Memory-Efficient Design: Optional advanced memory management for optimized buffer management</li> </ul>"},{"location":"advanced/","title":"PhotoFF Advanced Topics","text":"<p>This guide covers advanced techniques for optimizing performance when working with the PhotoFF library. It focuses on efficient memory management, buffer reuse, and optimization strategies.</p>"},{"location":"advanced/#memory-management-strategies","title":"Memory Management Strategies","text":""},{"location":"advanced/#understanding-gpu-memory-allocation","title":"Understanding GPU Memory Allocation","text":"<p>PhotoFF's <code>CudaImage</code> objects allocate GPU memory. Creating and freeing these objects frequently can lead to memory fragmentation and performance degradation. Advanced applications should:</p> <ol> <li>Pre-allocate buffers at the start of your application</li> <li>Reuse these buffers for different operations</li> <li>Only free memory when truly done with processing</li> </ol>"},{"location":"advanced/#buffer-reuse-pattern","title":"Buffer Reuse Pattern","text":"<p>Most PhotoFF operations support a destination buffer parameter, allowing you to reuse existing GPU memory:</p> <pre><code>from photoff.core.types import CudaImage\nfrom photoff.operations.resize import resize, ResizeMethod\n\n# Create buffers once\noriginal = CudaImage(1920, 1080)\nresized_cache = CudaImage(800, 600)  # Reusable buffer for resized images\n\n# Reuse the resized_cache buffer instead of allocating new memory\nresize(original, 800, 600, method=ResizeMethod.BICUBIC, resize_image_cache=resized_cache)\n</code></pre>"},{"location":"advanced/#real-world-example-collage-generator","title":"Real-World Example: Collage Generator","text":"<p>The following example demonstrates sophisticated buffer reuse in a production environment:</p> <pre><code>from photoff.core.types import CudaImage, RGBA\nfrom photoff.operations.filters import apply_corner_radius\nfrom photoff.operations.utils import cover_image_in_container, get_cover_resize_dimensions\nfrom photoff.operations.blend import blend\nfrom photoff.operations.resize import resize, ResizeMethod\nfrom photoff.operations.fill import fill_color\n\n# Pre-allocate all required buffers once\nPRINT_WIDTH = 2480\nPRINT_HEIGHT = 3500\nPREVIEW_WIDTH = 600\nPREVIEW_HEIGHT = 848\n\n# These buffers will be reused throughout the entire application lifecycle\nprint_collage_cache = CudaImage(PRINT_WIDTH, PRINT_HEIGHT)\npreview_collage_cache = CudaImage(PREVIEW_WIDTH, PREVIEW_HEIGHT)\ncover_cache = CudaImage(5000, 5000)\ncover_resize_cache = CudaImage(5000, 5000)\n\ndef create_collage(grid_data, corner_radius=50, background_color=RGBA(255, 255, 255, 255), padding=30):\n    # Reuse the print_collage_cache instead of creating a new buffer\n    fill_color(print_collage_cache, background_color)\n\n    for cell in grid_data.cells:\n        # Calculate dimensions\n        width = cell_width - padding*2\n        height = cell_height - padding*2\n\n        # Reuse the cover_cache buffer by adjusting its logical dimensions\n        # This avoids allocating new memory for each cell\n        cover_cache.width = width\n        cover_cache.height = height\n\n        # Calculate resize dimensions for the image to cover the cell\n        resize_size = get_cover_resize_dimensions(source_image, width, height)\n\n        # Reuse the resize cache buffer with new dimensions\n        cover_resize_cache.width = resize_size[0]\n        cover_resize_cache.height = resize_size[1]\n\n        # Place the image in the cell using the reused buffers\n        cover_image_in_container(\n            source_image,\n            width, height,\n            0, 0,\n            background_color,\n            container_image_cache=cover_cache,\n            resize_image_cache=cover_resize_cache\n        )\n\n        # Apply effects to the cell\n        apply_corner_radius(cover_cache, corner_radius)\n\n        # Blend the cell onto the main collage\n        blend(print_collage_cache, cover_cache, x_position, y_position)\n\n    # Create preview-sized version using the pre-allocated buffer\n    resize(\n        print_collage_cache, \n        PREVIEW_WIDTH, PREVIEW_HEIGHT, \n        method=ResizeMethod.BICUBIC,\n        resize_image_cache=preview_collage_cache\n    )\n\n    # Return the preview image (no need to free buffers as they are reused)\n    return preview_collage_cache\n</code></pre>"},{"location":"advanced/#working-with-temporary-buffers","title":"Working with Temporary Buffers","text":"<p>Many operations require temporary buffers for intermediate results. PhotoFF provides two approaches:</p>"},{"location":"advanced/#1-explicitly-providing-temporary-buffers","title":"1. Explicitly Providing Temporary Buffers","text":"<pre><code>from photoff.operations.filters import apply_gaussian_blur\nfrom photoff.core.types import CudaImage\n\n# Create the main image and a temporary buffer with the same dimensions\nimage = CudaImage(800, 600)\ntemp_buffer = CudaImage(800, 600)\n\n# Use the temporary buffer for operations that need it\napply_gaussian_blur(image, radius=5.0, image_copy_cache=temp_buffer)\n</code></pre>"},{"location":"advanced/#2-automatic-temporary-buffer-management","title":"2. Automatic Temporary Buffer Management","text":"<p>If you don't provide a temporary buffer, PhotoFF will create and free one automatically:</p> <pre><code># This works but is less efficient for repeated operations\napply_gaussian_blur(image, radius=5.0)  # Temporary buffer created and freed internally\n</code></pre>"},{"location":"advanced/#buffer-dimension-management","title":"Buffer Dimension Management","text":"<p>A unique feature of PhotoFF is the ability to reuse buffers even for different size requirements by adjusting their logical dimensions:</p> <pre><code># Create a large buffer once\nmulti_purpose_buffer = CudaImage(2000, 2000)\n\n# Use it for a 800x600 operation by changing the logical dimensions\nmulti_purpose_buffer.width = 800\nmulti_purpose_buffer.height = 600\n\n# Later, use it for a 1200x900 operation\nmulti_purpose_buffer.width = 1200\nmulti_purpose_buffer.height = 900\n</code></pre> <p>This technique allows you to minimize memory allocations by having a few large buffers that can be logically resized.</p>"},{"location":"advanced/#performance-tips","title":"Performance Tips","text":"<ol> <li> <p>Batch Similar Operations: Group similar operations to minimize context switching.</p> </li> <li> <p>Size Buffers Appropriately: Allocate buffers that are large enough for your maximum expected size, then adjust the logical dimensions as needed.</p> </li> <li> <p>Minimize Host-Device Transfers: Loading and saving images involves transferring data between CPU and GPU memory, which is slow. Perform all processing on the GPU before transferring back to the CPU.</p> </li> <li> <p>Profile Your Application: Use timing functions to identify bottlenecks:</p> </li> </ol> <pre><code>from time import time\n\nstart = time()\n# Your operation\nend = time()\nprint(f\"Operation took {end - start:.4f} seconds\")\n</code></pre> <ol> <li>Cache Images: If you repeatedly use the same source images, keep them loaded in GPU memory.</li> </ol>"},{"location":"advanced/#cleanup-strategies","title":"Cleanup Strategies","text":"<p>Even with buffer reuse, proper cleanup is essential. Establish clear ownership patterns for GPU resources:</p> <ol> <li> <p>Functions that create <code>CudaImage</code> objects should explicitly document whether the caller is responsible for freeing them.</p> </li> <li> <p>Consider using context managers for automatic cleanup:</p> </li> </ol> <pre><code>from contextlib import contextmanager\n\n@contextmanager\ndef using_cuda_image(width, height):\n    image = CudaImage(width, height)\n    try:\n        yield image\n    finally:\n        image.free()\n\n# Usage\nwith using_cuda_image(800, 600) as img:\n    # Use img here\n    fill_color(img, RGBA(255, 0, 0, 255))\n    # img will be automatically freed when the block exits\n</code></pre> <p>By implementing these advanced strategies, your PhotoFF applications can achieve maximum performance while maintaining clean, maintainable code.</p>"},{"location":"api/","title":"API","text":"<p>PhotoFF is a high-performance image processing library that uses CUDA to achieve exceptional processing speeds. Designed to maximize performance through efficient GPU memory management.</p>"},{"location":"api/#basic-example","title":"Basic Example","text":"<pre><code>from photoff.operations.filters import apply_gaussian_blur, apply_corner_radius\nfrom photoff.io import save_image, load_image\nfrom photoff import Image\n\n# Load the image\nsrc_image = load_image(\"./assets/stock.jpg\")\n\n# Apply filters\napply_gaussian_blur(src_image, radius=5.0)\napply_corner_radius(src_image, size=200)\n\n# Save the result\nsave_image(src_image, \"./assets/gaussian_blur_test.png\")\n\n# Free resources\nsrc_image.free()\n</code></pre>"},{"location":"api/#key-features","title":"Key Features","text":"<ul> <li>CUDA-Accelerated Processing: Harness the power of your GPU for blazing-fast image operations</li> <li>Memory-Efficient Design: Optimized buffer management minimizes memory overhead</li> <li>Robust Image Manipulation: Comprehensive suite of operations including filters, transforms, and compositing</li> <li>Pythonic Interface: Clean, intuitive API designed for both beginners and advanced users</li> <li>Seamless Integration: Works with common image formats through PIL interoperability</li> </ul>"},{"location":"basics/","title":"PhotoFF Basics","text":"<p>This guide covers the fundamental concepts and operations of the PhotoFF library. After reading this, you'll understand how to load, manipulate, and save images using GPU acceleration.</p>"},{"location":"basics/#core-concepts","title":"Core Concepts","text":"<p>PhotoFF is built around a few key concepts:</p>"},{"location":"basics/#cudaimage","title":"CudaImage","text":"<p>The <code>CudaImage</code> class is the central object in PhotoFF. It represents an image stored in GPU memory as a RGBA buffer.</p> <pre><code>from photoff.core.types import CudaImage\n\n# Reserving GPU memory for an 800x600 image\nimage = CudaImage(800, 600)\n\n# Always free GPU memory when done\nimage.free()\n</code></pre>"},{"location":"basics/#rgba","title":"RGBA","text":"<p>PhotoFF uses the RGBA color model (Red, Green, Blue, Alpha) for all operations:</p> <pre><code>from photoff.core.types import RGBA\n\n# Create colors\nred = RGBA(255, 0, 0, 255)         # Solid red\nblue = RGBA(0, 0, 255, 255)        # Solid blue\nsemi_transparent = RGBA(0, 255, 0, 128)  # Semi-transparent green\ntransparent = RGBA(0, 0, 0, 0)     # Completely transparent\n</code></pre>"},{"location":"basics/#basic-operations","title":"Basic Operations","text":""},{"location":"basics/#loading-and-saving-images","title":"Loading and Saving Images","text":"<p>To load images from disk and save them back:</p> <pre><code>from photoff.io import load_image, save_image\nfrom photoff.core.types import CudaImage\n\n# Load an image from disk into GPU memory\nimage = load_image(\"input.jpg\")\n\n# Save an image to disk\nsave_image(image, \"output.png\")\n\n# Always free memory when done\nimage.free()\n</code></pre>"},{"location":"basics/#image-filling","title":"Image Filling","text":"<p>Fill an image with a solid color or gradient:</p> <pre><code>from photoff.operations.fill import fill_color, fill_gradient\nfrom photoff.core.types import CudaImage, RGBA\n\n# Create and fill with solid color\nimage = CudaImage(400, 300)\nfill_color(image, RGBA(255, 0, 0, 255))  # Fill with red\n\n# Fill with gradient\nstart_color = RGBA(255, 0, 0, 255)  # Red\nend_color = RGBA(0, 0, 255, 255)    # Blue\ndirection = 0  # 0: horizontal, 1: vertical, 2: diagonal, 3: radial\nseamless = False\nfill_gradient(image, start_color, end_color, direction, seamless)\n\n# Don't forget to free\nimage.free()\n</code></pre>"},{"location":"basics/#applying-filters","title":"Applying Filters","text":"<p>PhotoFF offers various filters to modify images:</p> <pre><code>from photoff.operations.filters import apply_gaussian_blur, apply_corner_radius, apply_grayscale\nfrom photoff.io import load_image, save_image\n\n# Load an image\nimage = load_image(\"input.jpg\")\n\n# Apply a Gaussian blur\napply_gaussian_blur(image, radius=5.0)\n\n# Round the corners\napply_corner_radius(image, size=20)\n\n# Convert to grayscale\napply_grayscale(image)\n\n# Save the result\nsave_image(image, \"filtered.png\")\nimage.free()\n</code></pre>"},{"location":"basics/#resizing-images","title":"Resizing Images","text":"<p>Resize images with different interpolation methods:</p> <pre><code>from photoff.operations.resize import resize, ResizeMethod\nfrom photoff.io import load_image, save_image\n\n# Load an image\nimage = load_image(\"input.jpg\")\n\n# Resize to 400x300 using bicubic interpolation\nresized = resize(image, 400, 300, method=ResizeMethod.BICUBIC)\n\n# Save the result\nsave_image(resized, \"resized.png\")\n\n# Free both images\nimage.free()\nresized.free()\n</code></pre>"},{"location":"basics/#blending-images","title":"Blending Images","text":"<p>Combine multiple images together:</p> <pre><code>from photoff.operations.blend import blend\nfrom photoff.io import load_image, save_image\nfrom photoff.core.types import CudaImage, RGBA\nfrom photoff.operations.fill import fill_color\n\n# Create a background\nbackground = CudaImage(800, 600)\nfill_color(background, RGBA(200, 200, 200, 255))  # Light gray\n\n# Load a foreground image\nforeground = load_image(\"logo.png\")\n\n# Blend the foreground onto the background at position (100, 100)\nblend(background, foreground, 100, 100)\n\n# Save the result\nsave_image(background, \"blended.png\")\n\n# Free memory\nbackground.free()\nforeground.free()\n</code></pre>"},{"location":"basics/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, you can:</p> <ul> <li>Explore the Advanced Topics for more memory management and performance tips</li> <li>Check the API Reference for detailed information on all functions</li> <li>Try combining multiple effects to create unique image transformations</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing PhotoFF, ensure you have the following prerequisites:</p> <ul> <li>Python 3.9 or newer</li> <li>NVIDIA GPU with CUDA support</li> <li>CUDA Toolkit 11.0 or newer - Required for compiling the CUDA components</li> <li>Visual Studio with C++ support (Windows) - Required for the CUDA compiler</li> </ul>"},{"location":"installation/#installing-cuda-toolkit","title":"Installing CUDA Toolkit","text":"<ol> <li>Download the CUDA Toolkit from the NVIDIA Developer website</li> <li>Follow the installation instructions for your operating system</li> <li>Make sure the CUDA binaries are in your system PATH (this usually happens automatically during installation)</li> <li>Verify your installation by running <code>nvcc --version</code> in your terminal</li> </ol>"},{"location":"installation/#install-from-source","title":"Install from Source","text":"<p>This method builds and installs the package from source code:</p> <ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/offerrall/photoff.git\ncd photoff\n</code></pre></p> </li> <li> <p>Compile the CUDA DLL:    <pre><code>python photoff_cuda_src/compile.py\n</code></pre></p> </li> <li> <p>Move the compiled <code>photoff.dll</code> to a directory in your system PATH or add the directory containing the DLL to your PATH environment variable.</p> </li> <li> <p>Install the Python package:    <pre><code>pip install .\n</code></pre></p> </li> </ol>"},{"location":"installation/#verifying-the-installation","title":"Verifying the Installation","text":"<p>To verify your installation, run the following Python code:</p> <pre><code>from photoff.operations.fill import fill_color\nfrom photoff.io import save_image\nfrom photoff.core.types import CudaImage, RGBA\n\n# Create a 200x200 red square\nimg = CudaImage(200, 200)\nfill_color(img, RGBA(255, 0, 0, 255))\nsave_image(img, \"red_square.png\")\nimg.free()\n\nprint(\"Installation successful!\")\n</code></pre> <p>If you see a 200x200 red square image saved as \"red_square.png\" and the message \"Installation successful!\" printed to the console, your installation is working correctly.</p>"}]}